import * as fs from "node:fs/promises";
import * as util from "node:util";
import * as child_process from "node:child_process";
import * as semver from "semver";

const exec = util.promisify(child_process.exec);

const MANUAL_REDIRECTS = {
  "/main/*": "/:splat",
  "/latest/*": "/:splat",
  "/code_of_conduct": "/contribute/code-of-conduct",
  "/support": "/community/support",
  "/security": "/community/security",
  "/contribute": "/contribute/contributor-guide",
  "/metrics-endpoints": "/metric",
  "/pepr-tutorials/": "/tutorials/",
};

async function fetchGitTags(coreRepoPath) {
  const { stdout } = await exec("git tag", { cwd: coreRepoPath });
  return stdout.trim().split("\n").filter(Boolean).filter(semver.valid);
}

function sectionHeader(title, description) {
  return [
    "",
    "# ============================================",
    `# ${title}`,
    `# ${description}`,
    "# ============================================",
    "",
  ];
}

function matchesMajorMinor(version, majmin) {
  const match = version.match(/^v(\d+\.\d+)\.(\d+)$/);
  return match && match[1] === majmin;
}

export function generateManualRedirects() {
  const lines = [...sectionHeader("Manual Redirects", "Specific path redirects and fixes")];
  let count = 0;

  for (const [from, to] of Object.entries(MANUAL_REDIRECTS)) {
    const fromPath = !from.includes("*") && !from.includes(":path") ? `${from}/*` : from;
    const toPath = !to.includes("*") && !to.includes(":") ? `${to}/:splat` : to;
    lines.push(`${fromPath}  ${toPath}  301`);
    count++;
  }

  return { lines, count };
}

export function generatePatchToMinorRedirects(activeVersions, allTags) {
  const stableVersions = activeVersions.filter(v => semver.prerelease(v) === null);
  const activeMajorMinors = [
    ...new Set(stableVersions.map(v => v.replace(/^v(\d+\.\d+)\.\d+$/, "v$1"))),
  ];

  const lines = [
    ...sectionHeader(
      "Automatic Patch-to-Minor Redirects",
      `Redirect all patch versions to their major.minor for active versions: ${activeMajorMinors.join(", ")}\n`,
    ),
  ];
  let count = 0;

  for (const majmin of activeMajorMinors) {
    const patchVersions = allTags.filter(v => {
      const match = v.match(/^v(\d+\.\d+)\.(\d+)$/);
      return match && `v${match[1]}` === majmin;
    });

    for (const patchVersion of patchVersions) {
      lines.push(`/${patchVersion}  /${majmin}  301`);
      lines.push(`/${patchVersion}/*  /${majmin}/:splat  301`);
      count += 2;
    }
  }

  return { lines, count };
}

export function generateRetiredVersionRedirects(retiredVersions, allTags) {
  const lines = [
    ...sectionHeader("Retired Version Redirects", "Redirect old documentation versions to root"),
  ];
  let count = 0;

  for (const majmin of retiredVersions) {
    lines.push(`/v${majmin}/*  /:splat  301`);
    count++;

    const patchVersions = allTags.filter(v => matchesMajorMinor(v, majmin));
    for (const patchVersion of patchVersions) {
      lines.push(`/${patchVersion}/*  /:splat  301`);
      count++;
    }
  }

  return { lines, count };
}

export async function generateNetlifyRedirects({
  coreRepoPath,
  retiredVersions,
  activeVersions,
  outputPath,
}) {
  const allTags = await fetchGitTags(coreRepoPath);

  const header = [
    "# Auto-generated redirects for Pepr documentation",
    "# Generated by scripts/redirects-generator.mjs - DO NOT EDIT MANUALLY",
    "",
  ];
  const manual = generateManualRedirects();
  const automatic = generatePatchToMinorRedirects(activeVersions, allTags);
  const retired = generateRetiredVersionRedirects(retiredVersions, allTags);

  const allLines = [...header, ...manual.lines, ...automatic.lines, ...retired.lines];
  await fs.writeFile(outputPath, allLines.join("\n") + "\n");

  return {
    totalRules: retired.count + manual.count + automatic.count,
    retiredCount: retired.count,
    manualCount: manual.count,
    patchCount: automatic.count,
  };
}

export function getStableVersions(versions) {
  return versions.filter(v => v !== "latest" && semver.prerelease(v) === null);
}
