[{"body":"","categories":"","description":"","excerpt":"","ref":"/","tags":"","title":""},{"body":"The /metrics endpoint provides metrics for the application that are collected via the MetricsCollector class. It uses the prom-client library and performance hooks from Node.js to gather and expose the metrics data in a format that can be scraped by Prometheus.\nMetrics Exposed The MetricsCollector exposes the following metrics:\npepr_errors: A counter that increments when an error event occurs in the application. pepr_alerts: A counter that increments when an alert event is triggered in the application. pepr_Mutate: A summary that provides the observed durations of mutation events in the application. pepr_Validate: A summary that provides the observed durations of validation events in the application. API Details Method: GET\nURL: /metrics\nResponse Type: text/plain\nStatus Codes:\n200 OK: On success, returns the current metrics from the application. Response Body: The response body is a plain text representation of the metrics data, according to the Prometheus exposition formats. It includes the metrics mentioned above.\nExamples Request GET /metrics Response `# HELP pepr_errors Mutation/Validate errors encountered # TYPE pepr_errors counter pepr_errors 5 # HELP pepr_alerts Mutation/Validate bad api token received # TYPE pepr_alerts counter pepr_alerts 10 # HELP pepr_Mutate Mutation operation summary # TYPE pepr_Mutate summary pepr_Mutate{quantile=\"0.01\"} 100.60707900021225 pepr_Mutate{quantile=\"0.05\"} 100.60707900021225 pepr_Mutate{quantile=\"0.5\"} 100.60707900021225 pepr_Mutate{quantile=\"0.9\"} 100.60707900021225 pepr_Mutate{quantile=\"0.95\"} 100.60707900021225 pepr_Mutate{quantile=\"0.99\"} 100.60707900021225 pepr_Mutate{quantile=\"0.999\"} 100.60707900021225 pepr_Mutate_sum 100.60707900021225 pepr_Mutate_count 1 # HELP pepr_Validate Validation operation summary # TYPE pepr_Validate summary pepr_Validate{quantile=\"0.01\"} 201.19413900002837 pepr_Validate{quantile=\"0.05\"} 201.19413900002837 pepr_Validate{quantile=\"0.5\"} 201.2137690000236 pepr_Validate{quantile=\"0.9\"} 201.23339900001884 pepr_Validate{quantile=\"0.95\"} 201.23339900001884 pepr_Validate{quantile=\"0.99\"} 201.23339900001884 pepr_Validate{quantile=\"0.999\"} 201.23339900001884 pepr_Validate_sum 402.4275380000472 pepr_Validate_count 2 Prometheus Operator If using the Prometheus Operator, the following ServiceMonitor example manifests can be used to scrape the /metrics endpoint for the admission and watcher controllers.\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: admission spec: selector: matchLabels: pepr.dev/controller: admission namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true --- apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: watcher spec: selector: matchLabels: pepr.dev/controller: watcher namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true ","categories":"","description":"","excerpt":"The /metrics endpoint provides metrics for the application that are …","ref":"/main/metrics/","tags":"","title":"/metrics Endpoint Documentation"},{"body":"The /metrics endpoint provides metrics for the application that are collected via the MetricsCollector class. It uses the prom-client library and performance hooks from Node.js to gather and expose the metrics data in a format that can be scraped by Prometheus.\nMetrics Exposed The MetricsCollector exposes the following metrics:\npepr_errors: A counter that increments when an error event occurs in the application. pepr_alerts: A counter that increments when an alert event is triggered in the application. pepr_Mutate: A summary that provides the observed durations of mutation events in the application. pepr_Validate: A summary that provides the observed durations of validation events in the application. API Details Method: GET\nURL: /metrics\nResponse Type: text/plain\nStatus Codes:\n200 OK: On success, returns the current metrics from the application. Response Body: The response body is a plain text representation of the metrics data, according to the Prometheus exposition formats. It includes the metrics mentioned above.\nExamples Request GET /metrics Response `# HELP pepr_errors Mutation/Validate errors encountered # TYPE pepr_errors counter pepr_errors 5 # HELP pepr_alerts Mutation/Validate bad api token received # TYPE pepr_alerts counter pepr_alerts 10 # HELP pepr_Mutate Mutation operation summary # TYPE pepr_Mutate summary pepr_Mutate{quantile=\"0.01\"} 100.60707900021225 pepr_Mutate{quantile=\"0.05\"} 100.60707900021225 pepr_Mutate{quantile=\"0.5\"} 100.60707900021225 pepr_Mutate{quantile=\"0.9\"} 100.60707900021225 pepr_Mutate{quantile=\"0.95\"} 100.60707900021225 pepr_Mutate{quantile=\"0.99\"} 100.60707900021225 pepr_Mutate{quantile=\"0.999\"} 100.60707900021225 pepr_Mutate_sum 100.60707900021225 pepr_Mutate_count 1 # HELP pepr_Validate Validation operation summary # TYPE pepr_Validate summary pepr_Validate{quantile=\"0.01\"} 201.19413900002837 pepr_Validate{quantile=\"0.05\"} 201.19413900002837 pepr_Validate{quantile=\"0.5\"} 201.2137690000236 pepr_Validate{quantile=\"0.9\"} 201.23339900001884 pepr_Validate{quantile=\"0.95\"} 201.23339900001884 pepr_Validate{quantile=\"0.99\"} 201.23339900001884 pepr_Validate{quantile=\"0.999\"} 201.23339900001884 pepr_Validate_sum 402.4275380000472 pepr_Validate_count 2 ","categories":"","description":"","excerpt":"The /metrics endpoint provides metrics for the application that are …","ref":"/v0.19.0/metrics/","tags":"","title":"/metrics Endpoint Documentation"},{"body":"The /metrics endpoint provides metrics for the application that are collected via the MetricsCollector class. It uses the prom-client library and performance hooks from Node.js to gather and expose the metrics data in a format that can be scraped by Prometheus.\nMetrics Exposed The MetricsCollector exposes the following metrics:\npepr_errors: A counter that increments when an error event occurs in the application. pepr_alerts: A counter that increments when an alert event is triggered in the application. pepr_Mutate: A summary that provides the observed durations of mutation events in the application. pepr_Validate: A summary that provides the observed durations of validation events in the application. API Details Method: GET\nURL: /metrics\nResponse Type: text/plain\nStatus Codes:\n200 OK: On success, returns the current metrics from the application. Response Body: The response body is a plain text representation of the metrics data, according to the Prometheus exposition formats. It includes the metrics mentioned above.\nExamples Request GET /metrics Response `# HELP pepr_errors Mutation/Validate errors encountered # TYPE pepr_errors counter pepr_errors 5 # HELP pepr_alerts Mutation/Validate bad api token received # TYPE pepr_alerts counter pepr_alerts 10 # HELP pepr_Mutate Mutation operation summary # TYPE pepr_Mutate summary pepr_Mutate{quantile=\"0.01\"} 100.60707900021225 pepr_Mutate{quantile=\"0.05\"} 100.60707900021225 pepr_Mutate{quantile=\"0.5\"} 100.60707900021225 pepr_Mutate{quantile=\"0.9\"} 100.60707900021225 pepr_Mutate{quantile=\"0.95\"} 100.60707900021225 pepr_Mutate{quantile=\"0.99\"} 100.60707900021225 pepr_Mutate{quantile=\"0.999\"} 100.60707900021225 pepr_Mutate_sum 100.60707900021225 pepr_Mutate_count 1 # HELP pepr_Validate Validation operation summary # TYPE pepr_Validate summary pepr_Validate{quantile=\"0.01\"} 201.19413900002837 pepr_Validate{quantile=\"0.05\"} 201.19413900002837 pepr_Validate{quantile=\"0.5\"} 201.2137690000236 pepr_Validate{quantile=\"0.9\"} 201.23339900001884 pepr_Validate{quantile=\"0.95\"} 201.23339900001884 pepr_Validate{quantile=\"0.99\"} 201.23339900001884 pepr_Validate{quantile=\"0.999\"} 201.23339900001884 pepr_Validate_sum 402.4275380000472 pepr_Validate_count 2 Prometheus Operator If using the Prometheus Operator, the following ServiceMonitor example manifests can be used to scrape the /metrics endpoint for the admission and watcher controllers.\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: admission spec: selector: matchLabels: pepr.dev/controller: admission namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true --- apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: watcher spec: selector: matchLabels: pepr.dev/controller: watcher namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true ","categories":"","description":"","excerpt":"The /metrics endpoint provides metrics for the application that are …","ref":"/v0.20.0/metrics/","tags":"","title":"/metrics Endpoint Documentation"},{"body":"The /metrics endpoint provides metrics for the application that are collected via the MetricsCollector class. It uses the prom-client library and performance hooks from Node.js to gather and expose the metrics data in a format that can be scraped by Prometheus.\nMetrics Exposed The MetricsCollector exposes the following metrics:\npepr_errors: A counter that increments when an error event occurs in the application. pepr_alerts: A counter that increments when an alert event is triggered in the application. pepr_Mutate: A summary that provides the observed durations of mutation events in the application. pepr_Validate: A summary that provides the observed durations of validation events in the application. API Details Method: GET\nURL: /metrics\nResponse Type: text/plain\nStatus Codes:\n200 OK: On success, returns the current metrics from the application. Response Body: The response body is a plain text representation of the metrics data, according to the Prometheus exposition formats. It includes the metrics mentioned above.\nExamples Request GET /metrics Response `# HELP pepr_errors Mutation/Validate errors encountered # TYPE pepr_errors counter pepr_errors 5 # HELP pepr_alerts Mutation/Validate bad api token received # TYPE pepr_alerts counter pepr_alerts 10 # HELP pepr_Mutate Mutation operation summary # TYPE pepr_Mutate summary pepr_Mutate{quantile=\"0.01\"} 100.60707900021225 pepr_Mutate{quantile=\"0.05\"} 100.60707900021225 pepr_Mutate{quantile=\"0.5\"} 100.60707900021225 pepr_Mutate{quantile=\"0.9\"} 100.60707900021225 pepr_Mutate{quantile=\"0.95\"} 100.60707900021225 pepr_Mutate{quantile=\"0.99\"} 100.60707900021225 pepr_Mutate{quantile=\"0.999\"} 100.60707900021225 pepr_Mutate_sum 100.60707900021225 pepr_Mutate_count 1 # HELP pepr_Validate Validation operation summary # TYPE pepr_Validate summary pepr_Validate{quantile=\"0.01\"} 201.19413900002837 pepr_Validate{quantile=\"0.05\"} 201.19413900002837 pepr_Validate{quantile=\"0.5\"} 201.2137690000236 pepr_Validate{quantile=\"0.9\"} 201.23339900001884 pepr_Validate{quantile=\"0.95\"} 201.23339900001884 pepr_Validate{quantile=\"0.99\"} 201.23339900001884 pepr_Validate{quantile=\"0.999\"} 201.23339900001884 pepr_Validate_sum 402.4275380000472 pepr_Validate_count 2 Prometheus Operator If using the Prometheus Operator, the following ServiceMonitor example manifests can be used to scrape the /metrics endpoint for the admission and watcher controllers.\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: admission spec: selector: matchLabels: pepr.dev/controller: admission namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true --- apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: watcher spec: selector: matchLabels: pepr.dev/controller: watcher namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true ","categories":"","description":"","excerpt":"The /metrics endpoint provides metrics for the application that are …","ref":"/v0.20.1/metrics/","tags":"","title":"/metrics Endpoint Documentation"},{"body":"The /metrics endpoint provides metrics for the application that are collected via the MetricsCollector class. It uses the prom-client library and performance hooks from Node.js to gather and expose the metrics data in a format that can be scraped by Prometheus.\nMetrics Exposed The MetricsCollector exposes the following metrics:\npepr_errors: A counter that increments when an error event occurs in the application. pepr_alerts: A counter that increments when an alert event is triggered in the application. pepr_Mutate: A summary that provides the observed durations of mutation events in the application. pepr_Validate: A summary that provides the observed durations of validation events in the application. API Details Method: GET\nURL: /metrics\nResponse Type: text/plain\nStatus Codes:\n200 OK: On success, returns the current metrics from the application. Response Body: The response body is a plain text representation of the metrics data, according to the Prometheus exposition formats. It includes the metrics mentioned above.\nExamples Request GET /metrics Response `# HELP pepr_errors Mutation/Validate errors encountered # TYPE pepr_errors counter pepr_errors 5 # HELP pepr_alerts Mutation/Validate bad api token received # TYPE pepr_alerts counter pepr_alerts 10 # HELP pepr_Mutate Mutation operation summary # TYPE pepr_Mutate summary pepr_Mutate{quantile=\"0.01\"} 100.60707900021225 pepr_Mutate{quantile=\"0.05\"} 100.60707900021225 pepr_Mutate{quantile=\"0.5\"} 100.60707900021225 pepr_Mutate{quantile=\"0.9\"} 100.60707900021225 pepr_Mutate{quantile=\"0.95\"} 100.60707900021225 pepr_Mutate{quantile=\"0.99\"} 100.60707900021225 pepr_Mutate{quantile=\"0.999\"} 100.60707900021225 pepr_Mutate_sum 100.60707900021225 pepr_Mutate_count 1 # HELP pepr_Validate Validation operation summary # TYPE pepr_Validate summary pepr_Validate{quantile=\"0.01\"} 201.19413900002837 pepr_Validate{quantile=\"0.05\"} 201.19413900002837 pepr_Validate{quantile=\"0.5\"} 201.2137690000236 pepr_Validate{quantile=\"0.9\"} 201.23339900001884 pepr_Validate{quantile=\"0.95\"} 201.23339900001884 pepr_Validate{quantile=\"0.99\"} 201.23339900001884 pepr_Validate{quantile=\"0.999\"} 201.23339900001884 pepr_Validate_sum 402.4275380000472 pepr_Validate_count 2 Prometheus Operator If using the Prometheus Operator, the following ServiceMonitor example manifests can be used to scrape the /metrics endpoint for the admission and watcher controllers.\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: admission spec: selector: matchLabels: pepr.dev/controller: admission namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true --- apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: watcher spec: selector: matchLabels: pepr.dev/controller: watcher namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true ","categories":"","description":"","excerpt":"The /metrics endpoint provides metrics for the application that are …","ref":"/v0.20.2/metrics/","tags":"","title":"/metrics Endpoint Documentation"},{"body":"The /metrics endpoint provides metrics for the application that are collected via the MetricsCollector class. It uses the prom-client library and performance hooks from Node.js to gather and expose the metrics data in a format that can be scraped by Prometheus.\nMetrics Exposed The MetricsCollector exposes the following metrics:\npepr_errors: A counter that increments when an error event occurs in the application. pepr_alerts: A counter that increments when an alert event is triggered in the application. pepr_Mutate: A summary that provides the observed durations of mutation events in the application. pepr_Validate: A summary that provides the observed durations of validation events in the application. API Details Method: GET\nURL: /metrics\nResponse Type: text/plain\nStatus Codes:\n200 OK: On success, returns the current metrics from the application. Response Body: The response body is a plain text representation of the metrics data, according to the Prometheus exposition formats. It includes the metrics mentioned above.\nExamples Request GET /metrics Response `# HELP pepr_errors Mutation/Validate errors encountered # TYPE pepr_errors counter pepr_errors 5 # HELP pepr_alerts Mutation/Validate bad api token received # TYPE pepr_alerts counter pepr_alerts 10 # HELP pepr_Mutate Mutation operation summary # TYPE pepr_Mutate summary pepr_Mutate{quantile=\"0.01\"} 100.60707900021225 pepr_Mutate{quantile=\"0.05\"} 100.60707900021225 pepr_Mutate{quantile=\"0.5\"} 100.60707900021225 pepr_Mutate{quantile=\"0.9\"} 100.60707900021225 pepr_Mutate{quantile=\"0.95\"} 100.60707900021225 pepr_Mutate{quantile=\"0.99\"} 100.60707900021225 pepr_Mutate{quantile=\"0.999\"} 100.60707900021225 pepr_Mutate_sum 100.60707900021225 pepr_Mutate_count 1 # HELP pepr_Validate Validation operation summary # TYPE pepr_Validate summary pepr_Validate{quantile=\"0.01\"} 201.19413900002837 pepr_Validate{quantile=\"0.05\"} 201.19413900002837 pepr_Validate{quantile=\"0.5\"} 201.2137690000236 pepr_Validate{quantile=\"0.9\"} 201.23339900001884 pepr_Validate{quantile=\"0.95\"} 201.23339900001884 pepr_Validate{quantile=\"0.99\"} 201.23339900001884 pepr_Validate{quantile=\"0.999\"} 201.23339900001884 pepr_Validate_sum 402.4275380000472 pepr_Validate_count 2 Prometheus Operator If using the Prometheus Operator, the following ServiceMonitor example manifests can be used to scrape the /metrics endpoint for the admission and watcher controllers.\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: admission spec: selector: matchLabels: pepr.dev/controller: admission namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true --- apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: watcher spec: selector: matchLabels: pepr.dev/controller: watcher namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true ","categories":"","description":"","excerpt":"The /metrics endpoint provides metrics for the application that are …","ref":"/v0.20.3/metrics/","tags":"","title":"/metrics Endpoint Documentation"},{"body":"The /metrics endpoint provides metrics for the application that are collected via the MetricsCollector class. It uses the prom-client library and performance hooks from Node.js to gather and expose the metrics data in a format that can be scraped by Prometheus.\nMetrics Exposed The MetricsCollector exposes the following metrics:\npepr_errors: A counter that increments when an error event occurs in the application. pepr_alerts: A counter that increments when an alert event is triggered in the application. pepr_Mutate: A summary that provides the observed durations of mutation events in the application. pepr_Validate: A summary that provides the observed durations of validation events in the application. API Details Method: GET\nURL: /metrics\nResponse Type: text/plain\nStatus Codes:\n200 OK: On success, returns the current metrics from the application. Response Body: The response body is a plain text representation of the metrics data, according to the Prometheus exposition formats. It includes the metrics mentioned above.\nExamples Request GET /metrics Response `# HELP pepr_errors Mutation/Validate errors encountered # TYPE pepr_errors counter pepr_errors 5 # HELP pepr_alerts Mutation/Validate bad api token received # TYPE pepr_alerts counter pepr_alerts 10 # HELP pepr_Mutate Mutation operation summary # TYPE pepr_Mutate summary pepr_Mutate{quantile=\"0.01\"} 100.60707900021225 pepr_Mutate{quantile=\"0.05\"} 100.60707900021225 pepr_Mutate{quantile=\"0.5\"} 100.60707900021225 pepr_Mutate{quantile=\"0.9\"} 100.60707900021225 pepr_Mutate{quantile=\"0.95\"} 100.60707900021225 pepr_Mutate{quantile=\"0.99\"} 100.60707900021225 pepr_Mutate{quantile=\"0.999\"} 100.60707900021225 pepr_Mutate_sum 100.60707900021225 pepr_Mutate_count 1 # HELP pepr_Validate Validation operation summary # TYPE pepr_Validate summary pepr_Validate{quantile=\"0.01\"} 201.19413900002837 pepr_Validate{quantile=\"0.05\"} 201.19413900002837 pepr_Validate{quantile=\"0.5\"} 201.2137690000236 pepr_Validate{quantile=\"0.9\"} 201.23339900001884 pepr_Validate{quantile=\"0.95\"} 201.23339900001884 pepr_Validate{quantile=\"0.99\"} 201.23339900001884 pepr_Validate{quantile=\"0.999\"} 201.23339900001884 pepr_Validate_sum 402.4275380000472 pepr_Validate_count 2 Prometheus Operator If using the Prometheus Operator, the following ServiceMonitor example manifests can be used to scrape the /metrics endpoint for the admission and watcher controllers.\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: admission spec: selector: matchLabels: pepr.dev/controller: admission namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true --- apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: watcher spec: selector: matchLabels: pepr.dev/controller: watcher namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true ","categories":"","description":"","excerpt":"The /metrics endpoint provides metrics for the application that are …","ref":"/v0.21.0/metrics/","tags":"","title":"/metrics Endpoint Documentation"},{"body":"The /metrics endpoint provides metrics for the application that are collected via the MetricsCollector class. It uses the prom-client library and performance hooks from Node.js to gather and expose the metrics data in a format that can be scraped by Prometheus.\nMetrics Exposed The MetricsCollector exposes the following metrics:\npepr_errors: A counter that increments when an error event occurs in the application. pepr_alerts: A counter that increments when an alert event is triggered in the application. pepr_Mutate: A summary that provides the observed durations of mutation events in the application. pepr_Validate: A summary that provides the observed durations of validation events in the application. API Details Method: GET\nURL: /metrics\nResponse Type: text/plain\nStatus Codes:\n200 OK: On success, returns the current metrics from the application. Response Body: The response body is a plain text representation of the metrics data, according to the Prometheus exposition formats. It includes the metrics mentioned above.\nExamples Request GET /metrics Response `# HELP pepr_errors Mutation/Validate errors encountered # TYPE pepr_errors counter pepr_errors 5 # HELP pepr_alerts Mutation/Validate bad api token received # TYPE pepr_alerts counter pepr_alerts 10 # HELP pepr_Mutate Mutation operation summary # TYPE pepr_Mutate summary pepr_Mutate{quantile=\"0.01\"} 100.60707900021225 pepr_Mutate{quantile=\"0.05\"} 100.60707900021225 pepr_Mutate{quantile=\"0.5\"} 100.60707900021225 pepr_Mutate{quantile=\"0.9\"} 100.60707900021225 pepr_Mutate{quantile=\"0.95\"} 100.60707900021225 pepr_Mutate{quantile=\"0.99\"} 100.60707900021225 pepr_Mutate{quantile=\"0.999\"} 100.60707900021225 pepr_Mutate_sum 100.60707900021225 pepr_Mutate_count 1 # HELP pepr_Validate Validation operation summary # TYPE pepr_Validate summary pepr_Validate{quantile=\"0.01\"} 201.19413900002837 pepr_Validate{quantile=\"0.05\"} 201.19413900002837 pepr_Validate{quantile=\"0.5\"} 201.2137690000236 pepr_Validate{quantile=\"0.9\"} 201.23339900001884 pepr_Validate{quantile=\"0.95\"} 201.23339900001884 pepr_Validate{quantile=\"0.99\"} 201.23339900001884 pepr_Validate{quantile=\"0.999\"} 201.23339900001884 pepr_Validate_sum 402.4275380000472 pepr_Validate_count 2 Prometheus Operator If using the Prometheus Operator, the following ServiceMonitor example manifests can be used to scrape the /metrics endpoint for the admission and watcher controllers.\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: admission spec: selector: matchLabels: pepr.dev/controller: admission namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true --- apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: watcher spec: selector: matchLabels: pepr.dev/controller: watcher namespaceSelector: matchNames: - pepr-system endpoints: - targetPort: 3000 scheme: https tlsConfig: insecureSkipVerify: true ","categories":"","description":"","excerpt":"The /metrics endpoint provides metrics for the application that are …","ref":"/v0.21.1/metrics/","tags":"","title":"/metrics Endpoint Documentation"},{"body":"An action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in during the admission controller lifecycle. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nActions are Mutate(), Validate(), or Watch(). Both Mutate and Validate actions run during the admission controller lifecycle, while Watch actions run in a separate controller that tracks changes to resources, including existing resources.\nLet’s look at some example actions that are included in the HelloPepr capability that is created for you when you pepr init:\nIn this first example, Pepr is adding a label and annotation to a ConfigMap with tne name example-1 when it is created. Comments are added to each line to explain in more detail what is happening.\n// When(a.\u003cKind\u003e) filters which GroupVersionKind (GVK) this action should act on. When(a.ConfigMap) // This limits the action to only act on new resources. .IsCreated() // This limits the action to only act on resources with the name \"example-1\". .WithName(\"example-1\") // Mutate() is where we define the actual behavior of this action. .Mutate(request =\u003e { // The request object is a wrapper around the K8s resource that Pepr is acting on. request // Here we are adding a label to the ConfigMap. .SetLabel(\"pepr\", \"was-here\") // And here we are adding an annotation. .SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Note that we are not returning anything here. This is because Pepr is tracking the changes in each action automatically. }); In this example, a Validate action rejects any ConfigMap in the pepr-demo namespace that has no data.\nWhen(a.ConfigMap) .IsCreated() .InNamespace(\"pepr-demo\") // Validate() is where we define the actual behavior of this action. .Validate(request =\u003e { // If data exists, approve the request. if (request.Raw.data) { return request.Approve(); } // Otherwise, reject the request with a message and optional code. return request.Deny(\"ConfigMap must have data\"); }); In this example, a Watch action on the name and phase of any ConfigMap.Watch actions run in a separate controller that tracks changes to resources, including existing resources so that you can react to changes in real-time. It is important to note that Watch actions are not run during the admission controller lifecycle, so they cannot be used to modify or validate resources. They also may run multiple times for the same resource, so it is important to make sure that your Watch actions are idempotent. In a future release, Pepr will provide a better way to control when a Watch action is run to avoid this issue.\nWhen(a.ConfigMap) // Watch() is where we define the actual behavior of this action. .Watch((cm, phase) =\u003e { Log.info(cm, `ConfigMap ${cm.metadata.name} was ${phase}`); }); There are many more examples in the `HelloPepr` capability that you can use as a reference when creating your own actions. Note that each time you run [`pepr update`](../cli#pepr-update), Pepr will automatically update the `HelloPepr` capability with the latest examples and best practices for you to reference and test directly in your Pepr Module. ","categories":"","description":"","excerpt":"An action is a discrete set of behaviors defined in a single function …","ref":"/main/actions/","tags":"","title":"Actions"},{"body":"An action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in during the admission controller lifecycle. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nActions are Mutate(), Validate(), or Watch(). Both Mutate and Validate actions run during the admission controller lifecycle, while Watch actions run in a separate controller that tracks changes to resources, including existing resources.\nLet’s look at some example actions that are included in the HelloPepr capability that is created for you when you pepr init:\nIn this first example, Pepr is adding a label and annotation to a ConfigMap with tne name example-1 when it is created. Comments are added to each line to explain in more detail what is happening.\n// When(a.\u003cKind\u003e) filters which GroupVersionKind (GVK) this action should act on. When(a.ConfigMap) // This limits the action to only act on new resources. .IsCreated() // This limits the action to only act on resources with the name \"example-1\". .WithName(\"example-1\") // Mutate() is where we define the actual behavior of this action. .Mutate(request =\u003e { // The request object is a wrapper around the K8s resource that Pepr is acting on. request // Here we are adding a label to the ConfigMap. .SetLabel(\"pepr\", \"was-here\") // And here we are adding an annotation. .SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Note that we are not returning anything here. This is because Pepr is tracking the changes in each action automatically. }); In this example, a Validate action rejects any ConfigMap in the pepr-demo namespace that has no data.\nWhen(a.ConfigMap) .IsCreated() .InNamespace(\"pepr-demo\") // Validate() is where we define the actual behavior of this action. .Validate(request =\u003e { // If data exists, approve the request. if (request.Raw.data) { return request.Approve(); } // Otherwise, reject the request with a message and optional code. return request.Deny(\"ConfigMap must have data\"); }); In this example, a Watch action on the name and phase of any ConfigMap.Watch actions run in a separate controller that tracks changes to resources, including existing resources so that you can react to changes in real-time. It is important to note that Watch actions are not run during the admission controller lifecycle, so they cannot be used to modify or validate resources. They also may run multiple times for the same resource, so it is important to make sure that your Watch actions are idempotent. In a future release, Pepr will provide a better way to control when a Watch action is run to avoid this issue.\nWhen(a.ConfigMap) // Watch() is where we define the actual behavior of this action. .Watch((cm, phase) =\u003e { Log.info(cm, `ConfigMap ${cm.metadata.name} was ${phase}`); }); There are many more examples in the `HelloPepr` capability that you can use as a reference when creating your own actions. Note that each time you run [`pepr update`](../cli#pepr-update), Pepr will automatically update the `HelloPepr` capability with the latest examples and best practices for you to reference and test directly in your Pepr Module. ","categories":"","description":"","excerpt":"An action is a discrete set of behaviors defined in a single function …","ref":"/v0.19.0/actions/","tags":"","title":"Actions"},{"body":"An action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in during the admission controller lifecycle. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nActions are Mutate(), Validate(), or Watch(). Both Mutate and Validate actions run during the admission controller lifecycle, while Watch actions run in a separate controller that tracks changes to resources, including existing resources.\nLet’s look at some example actions that are included in the HelloPepr capability that is created for you when you pepr init:\nIn this first example, Pepr is adding a label and annotation to a ConfigMap with tne name example-1 when it is created. Comments are added to each line to explain in more detail what is happening.\n// When(a.\u003cKind\u003e) filters which GroupVersionKind (GVK) this action should act on. When(a.ConfigMap) // This limits the action to only act on new resources. .IsCreated() // This limits the action to only act on resources with the name \"example-1\". .WithName(\"example-1\") // Mutate() is where we define the actual behavior of this action. .Mutate(request =\u003e { // The request object is a wrapper around the K8s resource that Pepr is acting on. request // Here we are adding a label to the ConfigMap. .SetLabel(\"pepr\", \"was-here\") // And here we are adding an annotation. .SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Note that we are not returning anything here. This is because Pepr is tracking the changes in each action automatically. }); In this example, a Validate action rejects any ConfigMap in the pepr-demo namespace that has no data.\nWhen(a.ConfigMap) .IsCreated() .InNamespace(\"pepr-demo\") // Validate() is where we define the actual behavior of this action. .Validate(request =\u003e { // If data exists, approve the request. if (request.Raw.data) { return request.Approve(); } // Otherwise, reject the request with a message and optional code. return request.Deny(\"ConfigMap must have data\"); }); In this example, a Watch action on the name and phase of any ConfigMap.Watch actions run in a separate controller that tracks changes to resources, including existing resources so that you can react to changes in real-time. It is important to note that Watch actions are not run during the admission controller lifecycle, so they cannot be used to modify or validate resources. They also may run multiple times for the same resource, so it is important to make sure that your Watch actions are idempotent. In a future release, Pepr will provide a better way to control when a Watch action is run to avoid this issue.\nWhen(a.ConfigMap) // Watch() is where we define the actual behavior of this action. .Watch((cm, phase) =\u003e { Log.info(cm, `ConfigMap ${cm.metadata.name} was ${phase}`); }); There are many more examples in the `HelloPepr` capability that you can use as a reference when creating your own actions. Note that each time you run [`pepr update`](../cli#pepr-update), Pepr will automatically update the `HelloPepr` capability with the latest examples and best practices for you to reference and test directly in your Pepr Module. ","categories":"","description":"","excerpt":"An action is a discrete set of behaviors defined in a single function …","ref":"/v0.20.0/actions/","tags":"","title":"Actions"},{"body":"An action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in during the admission controller lifecycle. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nActions are Mutate(), Validate(), or Watch(). Both Mutate and Validate actions run during the admission controller lifecycle, while Watch actions run in a separate controller that tracks changes to resources, including existing resources.\nLet’s look at some example actions that are included in the HelloPepr capability that is created for you when you pepr init:\nIn this first example, Pepr is adding a label and annotation to a ConfigMap with tne name example-1 when it is created. Comments are added to each line to explain in more detail what is happening.\n// When(a.\u003cKind\u003e) filters which GroupVersionKind (GVK) this action should act on. When(a.ConfigMap) // This limits the action to only act on new resources. .IsCreated() // This limits the action to only act on resources with the name \"example-1\". .WithName(\"example-1\") // Mutate() is where we define the actual behavior of this action. .Mutate(request =\u003e { // The request object is a wrapper around the K8s resource that Pepr is acting on. request // Here we are adding a label to the ConfigMap. .SetLabel(\"pepr\", \"was-here\") // And here we are adding an annotation. .SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Note that we are not returning anything here. This is because Pepr is tracking the changes in each action automatically. }); In this example, a Validate action rejects any ConfigMap in the pepr-demo namespace that has no data.\nWhen(a.ConfigMap) .IsCreated() .InNamespace(\"pepr-demo\") // Validate() is where we define the actual behavior of this action. .Validate(request =\u003e { // If data exists, approve the request. if (request.Raw.data) { return request.Approve(); } // Otherwise, reject the request with a message and optional code. return request.Deny(\"ConfigMap must have data\"); }); In this example, a Watch action on the name and phase of any ConfigMap.Watch actions run in a separate controller that tracks changes to resources, including existing resources so that you can react to changes in real-time. It is important to note that Watch actions are not run during the admission controller lifecycle, so they cannot be used to modify or validate resources. They also may run multiple times for the same resource, so it is important to make sure that your Watch actions are idempotent. In a future release, Pepr will provide a better way to control when a Watch action is run to avoid this issue.\nWhen(a.ConfigMap) // Watch() is where we define the actual behavior of this action. .Watch((cm, phase) =\u003e { Log.info(cm, `ConfigMap ${cm.metadata.name} was ${phase}`); }); There are many more examples in the `HelloPepr` capability that you can use as a reference when creating your own actions. Note that each time you run [`pepr update`](../cli#pepr-update), Pepr will automatically update the `HelloPepr` capability with the latest examples and best practices for you to reference and test directly in your Pepr Module. ","categories":"","description":"","excerpt":"An action is a discrete set of behaviors defined in a single function …","ref":"/v0.20.1/actions/","tags":"","title":"Actions"},{"body":"An action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in during the admission controller lifecycle. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nActions are Mutate(), Validate(), or Watch(). Both Mutate and Validate actions run during the admission controller lifecycle, while Watch actions run in a separate controller that tracks changes to resources, including existing resources.\nLet’s look at some example actions that are included in the HelloPepr capability that is created for you when you pepr init:\nIn this first example, Pepr is adding a label and annotation to a ConfigMap with tne name example-1 when it is created. Comments are added to each line to explain in more detail what is happening.\n// When(a.\u003cKind\u003e) filters which GroupVersionKind (GVK) this action should act on. When(a.ConfigMap) // This limits the action to only act on new resources. .IsCreated() // This limits the action to only act on resources with the name \"example-1\". .WithName(\"example-1\") // Mutate() is where we define the actual behavior of this action. .Mutate(request =\u003e { // The request object is a wrapper around the K8s resource that Pepr is acting on. request // Here we are adding a label to the ConfigMap. .SetLabel(\"pepr\", \"was-here\") // And here we are adding an annotation. .SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Note that we are not returning anything here. This is because Pepr is tracking the changes in each action automatically. }); In this example, a Validate action rejects any ConfigMap in the pepr-demo namespace that has no data.\nWhen(a.ConfigMap) .IsCreated() .InNamespace(\"pepr-demo\") // Validate() is where we define the actual behavior of this action. .Validate(request =\u003e { // If data exists, approve the request. if (request.Raw.data) { return request.Approve(); } // Otherwise, reject the request with a message and optional code. return request.Deny(\"ConfigMap must have data\"); }); In this example, a Watch action on the name and phase of any ConfigMap.Watch actions run in a separate controller that tracks changes to resources, including existing resources so that you can react to changes in real-time. It is important to note that Watch actions are not run during the admission controller lifecycle, so they cannot be used to modify or validate resources. They also may run multiple times for the same resource, so it is important to make sure that your Watch actions are idempotent. In a future release, Pepr will provide a better way to control when a Watch action is run to avoid this issue.\nWhen(a.ConfigMap) // Watch() is where we define the actual behavior of this action. .Watch((cm, phase) =\u003e { Log.info(cm, `ConfigMap ${cm.metadata.name} was ${phase}`); }); There are many more examples in the `HelloPepr` capability that you can use as a reference when creating your own actions. Note that each time you run [`pepr update`](../cli#pepr-update), Pepr will automatically update the `HelloPepr` capability with the latest examples and best practices for you to reference and test directly in your Pepr Module. ","categories":"","description":"","excerpt":"An action is a discrete set of behaviors defined in a single function …","ref":"/v0.20.2/actions/","tags":"","title":"Actions"},{"body":"An action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in during the admission controller lifecycle. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nActions are Mutate(), Validate(), or Watch(). Both Mutate and Validate actions run during the admission controller lifecycle, while Watch actions run in a separate controller that tracks changes to resources, including existing resources.\nLet’s look at some example actions that are included in the HelloPepr capability that is created for you when you pepr init:\nIn this first example, Pepr is adding a label and annotation to a ConfigMap with tne name example-1 when it is created. Comments are added to each line to explain in more detail what is happening.\n// When(a.\u003cKind\u003e) filters which GroupVersionKind (GVK) this action should act on. When(a.ConfigMap) // This limits the action to only act on new resources. .IsCreated() // This limits the action to only act on resources with the name \"example-1\". .WithName(\"example-1\") // Mutate() is where we define the actual behavior of this action. .Mutate(request =\u003e { // The request object is a wrapper around the K8s resource that Pepr is acting on. request // Here we are adding a label to the ConfigMap. .SetLabel(\"pepr\", \"was-here\") // And here we are adding an annotation. .SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Note that we are not returning anything here. This is because Pepr is tracking the changes in each action automatically. }); In this example, a Validate action rejects any ConfigMap in the pepr-demo namespace that has no data.\nWhen(a.ConfigMap) .IsCreated() .InNamespace(\"pepr-demo\") // Validate() is where we define the actual behavior of this action. .Validate(request =\u003e { // If data exists, approve the request. if (request.Raw.data) { return request.Approve(); } // Otherwise, reject the request with a message and optional code. return request.Deny(\"ConfigMap must have data\"); }); In this example, a Watch action on the name and phase of any ConfigMap.Watch actions run in a separate controller that tracks changes to resources, including existing resources so that you can react to changes in real-time. It is important to note that Watch actions are not run during the admission controller lifecycle, so they cannot be used to modify or validate resources. They also may run multiple times for the same resource, so it is important to make sure that your Watch actions are idempotent. In a future release, Pepr will provide a better way to control when a Watch action is run to avoid this issue.\nWhen(a.ConfigMap) // Watch() is where we define the actual behavior of this action. .Watch((cm, phase) =\u003e { Log.info(cm, `ConfigMap ${cm.metadata.name} was ${phase}`); }); There are many more examples in the `HelloPepr` capability that you can use as a reference when creating your own actions. Note that each time you run [`pepr update`](../cli#pepr-update), Pepr will automatically update the `HelloPepr` capability with the latest examples and best practices for you to reference and test directly in your Pepr Module. ","categories":"","description":"","excerpt":"An action is a discrete set of behaviors defined in a single function …","ref":"/v0.20.3/actions/","tags":"","title":"Actions"},{"body":"An action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in during the admission controller lifecycle. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nActions are Mutate(), Validate(), or Watch(). Both Mutate and Validate actions run during the admission controller lifecycle, while Watch actions run in a separate controller that tracks changes to resources, including existing resources.\nLet’s look at some example actions that are included in the HelloPepr capability that is created for you when you pepr init:\nIn this first example, Pepr is adding a label and annotation to a ConfigMap with tne name example-1 when it is created. Comments are added to each line to explain in more detail what is happening.\n// When(a.\u003cKind\u003e) filters which GroupVersionKind (GVK) this action should act on. When(a.ConfigMap) // This limits the action to only act on new resources. .IsCreated() // This limits the action to only act on resources with the name \"example-1\". .WithName(\"example-1\") // Mutate() is where we define the actual behavior of this action. .Mutate(request =\u003e { // The request object is a wrapper around the K8s resource that Pepr is acting on. request // Here we are adding a label to the ConfigMap. .SetLabel(\"pepr\", \"was-here\") // And here we are adding an annotation. .SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Note that we are not returning anything here. This is because Pepr is tracking the changes in each action automatically. }); In this example, a Validate action rejects any ConfigMap in the pepr-demo namespace that has no data.\nWhen(a.ConfigMap) .IsCreated() .InNamespace(\"pepr-demo\") // Validate() is where we define the actual behavior of this action. .Validate(request =\u003e { // If data exists, approve the request. if (request.Raw.data) { return request.Approve(); } // Otherwise, reject the request with a message and optional code. return request.Deny(\"ConfigMap must have data\"); }); In this example, a Watch action on the name and phase of any ConfigMap.Watch actions run in a separate controller that tracks changes to resources, including existing resources so that you can react to changes in real-time. It is important to note that Watch actions are not run during the admission controller lifecycle, so they cannot be used to modify or validate resources. They also may run multiple times for the same resource, so it is important to make sure that your Watch actions are idempotent. In a future release, Pepr will provide a better way to control when a Watch action is run to avoid this issue.\nWhen(a.ConfigMap) // Watch() is where we define the actual behavior of this action. .Watch((cm, phase) =\u003e { Log.info(cm, `ConfigMap ${cm.metadata.name} was ${phase}`); }); There are many more examples in the `HelloPepr` capability that you can use as a reference when creating your own actions. Note that each time you run [`pepr update`](../cli#pepr-update), Pepr will automatically update the `HelloPepr` capability with the latest examples and best practices for you to reference and test directly in your Pepr Module. ","categories":"","description":"","excerpt":"An action is a discrete set of behaviors defined in a single function …","ref":"/v0.21.0/actions/","tags":"","title":"Actions"},{"body":"An action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in during the admission controller lifecycle. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nActions are Mutate(), Validate(), or Watch(). Both Mutate and Validate actions run during the admission controller lifecycle, while Watch actions run in a separate controller that tracks changes to resources, including existing resources.\nLet’s look at some example actions that are included in the HelloPepr capability that is created for you when you pepr init:\nIn this first example, Pepr is adding a label and annotation to a ConfigMap with tne name example-1 when it is created. Comments are added to each line to explain in more detail what is happening.\n// When(a.\u003cKind\u003e) filters which GroupVersionKind (GVK) this action should act on. When(a.ConfigMap) // This limits the action to only act on new resources. .IsCreated() // This limits the action to only act on resources with the name \"example-1\". .WithName(\"example-1\") // Mutate() is where we define the actual behavior of this action. .Mutate(request =\u003e { // The request object is a wrapper around the K8s resource that Pepr is acting on. request // Here we are adding a label to the ConfigMap. .SetLabel(\"pepr\", \"was-here\") // And here we are adding an annotation. .SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Note that we are not returning anything here. This is because Pepr is tracking the changes in each action automatically. }); In this example, a Validate action rejects any ConfigMap in the pepr-demo namespace that has no data.\nWhen(a.ConfigMap) .IsCreated() .InNamespace(\"pepr-demo\") // Validate() is where we define the actual behavior of this action. .Validate(request =\u003e { // If data exists, approve the request. if (request.Raw.data) { return request.Approve(); } // Otherwise, reject the request with a message and optional code. return request.Deny(\"ConfigMap must have data\"); }); In this example, a Watch action on the name and phase of any ConfigMap.Watch actions run in a separate controller that tracks changes to resources, including existing resources so that you can react to changes in real-time. It is important to note that Watch actions are not run during the admission controller lifecycle, so they cannot be used to modify or validate resources. They also may run multiple times for the same resource, so it is important to make sure that your Watch actions are idempotent. In a future release, Pepr will provide a better way to control when a Watch action is run to avoid this issue.\nWhen(a.ConfigMap) // Watch() is where we define the actual behavior of this action. .Watch((cm, phase) =\u003e { Log.info(cm, `ConfigMap ${cm.metadata.name} was ${phase}`); }); There are many more examples in the `HelloPepr` capability that you can use as a reference when creating your own actions. Note that each time you run [`pepr update`](../cli#pepr-update), Pepr will automatically update the `HelloPepr` capability with the latest examples and best practices for you to reference and test directly in your Pepr Module. ","categories":"","description":"","excerpt":"An action is a discrete set of behaviors defined in a single function …","ref":"/v0.21.1/actions/","tags":"","title":"Actions"},{"body":"A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nWhen you pepr init, a capabilities directory is created for you. This directory is where you will define your capabilities. You can create as many capabilities as you need, and each capability can contain one or more actions. Pepr also automatically creates a HelloPepr capability with a number of example actions to help you get started.\nCreating a Capability Defining a new capability can be done via a VSCode Snippet generated during pepr init.\nCreate a new file in the capabilities directory with the name of your capability. For example, capabilities/my-capability.ts.\nOpen the new file in VSCode and type create in the file. A suggestion should prompt you to generate the content from there.\nIf you prefer not to use VSCode, you can also modify or copy the HelloPepr capability to meet your needs instead.\nReusable Capabilities Pepr has an NPM org managed by Defense Unicorns, @pepr, where capabilities are published for reuse in other Pepr Modules. You can find a list of published capabilities here.\nYou also can publish your own Pepr capabilities to NPM and import them. A couple of things you’ll want to be aware of when publishing your own capabilities:\nReuseable capability versions should use the format 0.x.x or 0.12.x as examples to determine compatibility with other reusable capabilities. Before 1.x.x, we recommend binding to 0.x.x if you can for maximum compatibility.\npepr.ts will still be used for local development, but you’ll also need to publish an index.ts that exports your capabilities. When you build \u0026 publish the capability to NPM, you can use npx pepr build -e index.ts to generate the code needed for reuse by other Pepr modules.\nSee Pepr Istio for an example of a reusable capability.\n","categories":"","description":"","excerpt":"A capability is set of related actions that work together to achieve a …","ref":"/main/capabilities/","tags":"","title":"Capabilities"},{"body":"A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nWhen you pepr init, a capabilities directory is created for you. This directory is where you will define your capabilities. You can create as many capabilities as you need, and each capability can contain one or more actions. Pepr also automatically creates a HelloPepr capability with a number of example actions to help you get started.\nCreating a Capability Defining a new capability can be done via a VSCode Snippet generated during pepr init.\nCreate a new file in the capabilities directory with the name of your capability. For example, capabilities/my-capability.ts.\nOpen the new file in VSCode and type create in the file. A suggestion should prompt you to generate the content from there.\nIf you prefer not to use VSCode, you can also modify or copy the HelloPepr capability to meet your needs instead.\nReusable Capabilities Pepr has an NPM org managed by Defense Unicorns, @pepr, where capabilities are published for reuse in other Pepr Modules. You can find a list of published capabilities here.\nYou also can publish your own Pepr capabilities to NPM and import them. A couple of things you’ll want to be aware of when publishing your own capabilities:\nReuseable capability versions should use the format 0.x.x or 0.12.x as examples to determine compatibility with other reusable capabilities. Before 1.x.x, we recommend binding to 0.x.x if you can for maximum compatibility.\npepr.ts will still be used for local development, but you’ll also need to publish an index.ts that exports your capabilities. When you build \u0026 publish the capability to NPM, you can use npx pepr build -e index.ts to generate the code needed for reuse by other Pepr modules.\nSee Pepr Istio for an example of a reusable capability.\n","categories":"","description":"","excerpt":"A capability is set of related actions that work together to achieve a …","ref":"/v0.19.0/capabilities/","tags":"","title":"Capabilities"},{"body":"A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nWhen you pepr init, a capabilities directory is created for you. This directory is where you will define your capabilities. You can create as many capabilities as you need, and each capability can contain one or more actions. Pepr also automatically creates a HelloPepr capability with a number of example actions to help you get started.\nCreating a Capability Defining a new capability can be done via a VSCode Snippet generated during pepr init.\nCreate a new file in the capabilities directory with the name of your capability. For example, capabilities/my-capability.ts.\nOpen the new file in VSCode and type create in the file. A suggestion should prompt you to generate the content from there.\nIf you prefer not to use VSCode, you can also modify or copy the HelloPepr capability to meet your needs instead.\nReusable Capabilities Pepr has an NPM org managed by Defense Unicorns, @pepr, where capabilities are published for reuse in other Pepr Modules. You can find a list of published capabilities here.\nYou also can publish your own Pepr capabilities to NPM and import them. A couple of things you’ll want to be aware of when publishing your own capabilities:\nReuseable capability versions should use the format 0.x.x or 0.12.x as examples to determine compatibility with other reusable capabilities. Before 1.x.x, we recommend binding to 0.x.x if you can for maximum compatibility.\npepr.ts will still be used for local development, but you’ll also need to publish an index.ts that exports your capabilities. When you build \u0026 publish the capability to NPM, you can use npx pepr build -e index.ts to generate the code needed for reuse by other Pepr modules.\nSee Pepr Istio for an example of a reusable capability.\n","categories":"","description":"","excerpt":"A capability is set of related actions that work together to achieve a …","ref":"/v0.20.0/capabilities/","tags":"","title":"Capabilities"},{"body":"A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nWhen you pepr init, a capabilities directory is created for you. This directory is where you will define your capabilities. You can create as many capabilities as you need, and each capability can contain one or more actions. Pepr also automatically creates a HelloPepr capability with a number of example actions to help you get started.\nCreating a Capability Defining a new capability can be done via a VSCode Snippet generated during pepr init.\nCreate a new file in the capabilities directory with the name of your capability. For example, capabilities/my-capability.ts.\nOpen the new file in VSCode and type create in the file. A suggestion should prompt you to generate the content from there.\nIf you prefer not to use VSCode, you can also modify or copy the HelloPepr capability to meet your needs instead.\nReusable Capabilities Pepr has an NPM org managed by Defense Unicorns, @pepr, where capabilities are published for reuse in other Pepr Modules. You can find a list of published capabilities here.\nYou also can publish your own Pepr capabilities to NPM and import them. A couple of things you’ll want to be aware of when publishing your own capabilities:\nReuseable capability versions should use the format 0.x.x or 0.12.x as examples to determine compatibility with other reusable capabilities. Before 1.x.x, we recommend binding to 0.x.x if you can for maximum compatibility.\npepr.ts will still be used for local development, but you’ll also need to publish an index.ts that exports your capabilities. When you build \u0026 publish the capability to NPM, you can use npx pepr build -e index.ts to generate the code needed for reuse by other Pepr modules.\nSee Pepr Istio for an example of a reusable capability.\n","categories":"","description":"","excerpt":"A capability is set of related actions that work together to achieve a …","ref":"/v0.20.1/capabilities/","tags":"","title":"Capabilities"},{"body":"A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nWhen you pepr init, a capabilities directory is created for you. This directory is where you will define your capabilities. You can create as many capabilities as you need, and each capability can contain one or more actions. Pepr also automatically creates a HelloPepr capability with a number of example actions to help you get started.\nCreating a Capability Defining a new capability can be done via a VSCode Snippet generated during pepr init.\nCreate a new file in the capabilities directory with the name of your capability. For example, capabilities/my-capability.ts.\nOpen the new file in VSCode and type create in the file. A suggestion should prompt you to generate the content from there.\nIf you prefer not to use VSCode, you can also modify or copy the HelloPepr capability to meet your needs instead.\nReusable Capabilities Pepr has an NPM org managed by Defense Unicorns, @pepr, where capabilities are published for reuse in other Pepr Modules. You can find a list of published capabilities here.\nYou also can publish your own Pepr capabilities to NPM and import them. A couple of things you’ll want to be aware of when publishing your own capabilities:\nReuseable capability versions should use the format 0.x.x or 0.12.x as examples to determine compatibility with other reusable capabilities. Before 1.x.x, we recommend binding to 0.x.x if you can for maximum compatibility.\npepr.ts will still be used for local development, but you’ll also need to publish an index.ts that exports your capabilities. When you build \u0026 publish the capability to NPM, you can use npx pepr build -e index.ts to generate the code needed for reuse by other Pepr modules.\nSee Pepr Istio for an example of a reusable capability.\n","categories":"","description":"","excerpt":"A capability is set of related actions that work together to achieve a …","ref":"/v0.20.2/capabilities/","tags":"","title":"Capabilities"},{"body":"A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nWhen you pepr init, a capabilities directory is created for you. This directory is where you will define your capabilities. You can create as many capabilities as you need, and each capability can contain one or more actions. Pepr also automatically creates a HelloPepr capability with a number of example actions to help you get started.\nCreating a Capability Defining a new capability can be done via a VSCode Snippet generated during pepr init.\nCreate a new file in the capabilities directory with the name of your capability. For example, capabilities/my-capability.ts.\nOpen the new file in VSCode and type create in the file. A suggestion should prompt you to generate the content from there.\nIf you prefer not to use VSCode, you can also modify or copy the HelloPepr capability to meet your needs instead.\nReusable Capabilities Pepr has an NPM org managed by Defense Unicorns, @pepr, where capabilities are published for reuse in other Pepr Modules. You can find a list of published capabilities here.\nYou also can publish your own Pepr capabilities to NPM and import them. A couple of things you’ll want to be aware of when publishing your own capabilities:\nReuseable capability versions should use the format 0.x.x or 0.12.x as examples to determine compatibility with other reusable capabilities. Before 1.x.x, we recommend binding to 0.x.x if you can for maximum compatibility.\npepr.ts will still be used for local development, but you’ll also need to publish an index.ts that exports your capabilities. When you build \u0026 publish the capability to NPM, you can use npx pepr build -e index.ts to generate the code needed for reuse by other Pepr modules.\nSee Pepr Istio for an example of a reusable capability.\n","categories":"","description":"","excerpt":"A capability is set of related actions that work together to achieve a …","ref":"/v0.20.3/capabilities/","tags":"","title":"Capabilities"},{"body":"A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nWhen you pepr init, a capabilities directory is created for you. This directory is where you will define your capabilities. You can create as many capabilities as you need, and each capability can contain one or more actions. Pepr also automatically creates a HelloPepr capability with a number of example actions to help you get started.\nCreating a Capability Defining a new capability can be done via a VSCode Snippet generated during pepr init.\nCreate a new file in the capabilities directory with the name of your capability. For example, capabilities/my-capability.ts.\nOpen the new file in VSCode and type create in the file. A suggestion should prompt you to generate the content from there.\nIf you prefer not to use VSCode, you can also modify or copy the HelloPepr capability to meet your needs instead.\nReusable Capabilities Pepr has an NPM org managed by Defense Unicorns, @pepr, where capabilities are published for reuse in other Pepr Modules. You can find a list of published capabilities here.\nYou also can publish your own Pepr capabilities to NPM and import them. A couple of things you’ll want to be aware of when publishing your own capabilities:\nReuseable capability versions should use the format 0.x.x or 0.12.x as examples to determine compatibility with other reusable capabilities. Before 1.x.x, we recommend binding to 0.x.x if you can for maximum compatibility.\npepr.ts will still be used for local development, but you’ll also need to publish an index.ts that exports your capabilities. When you build \u0026 publish the capability to NPM, you can use npx pepr build -e index.ts to generate the code needed for reuse by other Pepr modules.\nSee Pepr Istio for an example of a reusable capability.\n","categories":"","description":"","excerpt":"A capability is set of related actions that work together to achieve a …","ref":"/v0.21.0/capabilities/","tags":"","title":"Capabilities"},{"body":"A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nWhen you pepr init, a capabilities directory is created for you. This directory is where you will define your capabilities. You can create as many capabilities as you need, and each capability can contain one or more actions. Pepr also automatically creates a HelloPepr capability with a number of example actions to help you get started.\nCreating a Capability Defining a new capability can be done via a VSCode Snippet generated during pepr init.\nCreate a new file in the capabilities directory with the name of your capability. For example, capabilities/my-capability.ts.\nOpen the new file in VSCode and type create in the file. A suggestion should prompt you to generate the content from there.\nIf you prefer not to use VSCode, you can also modify or copy the HelloPepr capability to meet your needs instead.\nReusable Capabilities Pepr has an NPM org managed by Defense Unicorns, @pepr, where capabilities are published for reuse in other Pepr Modules. You can find a list of published capabilities here.\nYou also can publish your own Pepr capabilities to NPM and import them. A couple of things you’ll want to be aware of when publishing your own capabilities:\nReuseable capability versions should use the format 0.x.x or 0.12.x as examples to determine compatibility with other reusable capabilities. Before 1.x.x, we recommend binding to 0.x.x if you can for maximum compatibility.\npepr.ts will still be used for local development, but you’ll also need to publish an index.ts that exports your capabilities. When you build \u0026 publish the capability to NPM, you can use npx pepr build -e index.ts to generate the code needed for reuse by other Pepr modules.\nSee Pepr Istio for an example of a reusable capability.\n","categories":"","description":"","excerpt":"A capability is set of related actions that work together to achieve a …","ref":"/v0.21.1/capabilities/","tags":"","title":"Capabilities"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"The Kubernetes Fluent Client supports the creation of TypeScript typings directly from Kubernetes Custom Resource Definitions (CRDs). The files it generates can be directly incorporated into Pepr capabilities and provide a way to work with strongly-typed CRDs.\nFor example (below), Istio CRDs can be imported and used as though they were intrinsic Kubernetes resources.\nGenerating TypeScript Types from CRDs Using the kubernetes-fluent-client to produce a new type looks like this:\nnpx kubernetes-fluent-client crd [source] [directory] The crd command expects a [source], which can be a URL or local file containing the CustomResourceDefinition(s), and a [directory] where the generated code will live.\nThe following example creates types for the Istio CRDs:\nuser@workstation$ npx kubernetes-fluent-client crd https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml crds Attempting to load https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml as a URL - Generating extensions.istio.io/v1alpha1 types for WasmPlugin - Generating networking.istio.io/v1alpha3 types for DestinationRule - Generating networking.istio.io/v1beta1 types for DestinationRule - Generating networking.istio.io/v1alpha3 types for EnvoyFilter - Generating networking.istio.io/v1alpha3 types for Gateway - Generating networking.istio.io/v1beta1 types for Gateway - Generating networking.istio.io/v1beta1 types for ProxyConfig - Generating networking.istio.io/v1alpha3 types for ServiceEntry - Generating networking.istio.io/v1beta1 types for ServiceEntry - Generating networking.istio.io/v1alpha3 types for Sidecar - Generating networking.istio.io/v1beta1 types for Sidecar - Generating networking.istio.io/v1alpha3 types for VirtualService - Generating networking.istio.io/v1beta1 types for VirtualService - Generating networking.istio.io/v1alpha3 types for WorkloadEntry - Generating networking.istio.io/v1beta1 types for WorkloadEntry - Generating networking.istio.io/v1alpha3 types for WorkloadGroup - Generating networking.istio.io/v1beta1 types for WorkloadGroup - Generating security.istio.io/v1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for PeerAuthentication - Generating security.istio.io/v1 types for RequestAuthentication - Generating security.istio.io/v1beta1 types for RequestAuthentication - Generating telemetry.istio.io/v1alpha1 types for Telemetry ✅ Generated 23 files in the istio directory Observe that the kubernetes-fluent-client has produced the TypeScript types within the crds directory. These types can now be utilized in the Pepr module.\nuser@workstation$ cat crds/proxyconfig-v1beta1.ts // This file is auto-generated by kubernetes-fluent-client, do not edit manually import { GenericKind, RegisterKind } from \"kubernetes-fluent-client\"; export class ProxyConfig extends GenericKind { /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ spec?: Spec; status?: { [key: string]: any }; } /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ export interface Spec { /** * The number of worker threads to run. */ concurrency?: number; /** * Additional environment variables for the proxy. */ environmentVariables?: { [key: string]: string }; /** * Specifies the details of the proxy image. */ image?: Image; /** * Optional. */ selector?: Selector; } /** * Specifies the details of the proxy image. */ export interface Image { /** * The image type of the image. */ imageType?: string; } /** * Optional. */ export interface Selector { /** * One or more labels that indicate a specific set of pods/VMs on which a policy should be * applied. */ matchLabels?: { [key: string]: string }; } RegisterKind(ProxyConfig, { group: \"networking.istio.io\", version: \"v1beta1\", kind: \"ProxyConfig\", }); Using new types The generated types can be imported into Pepr directly, there is no additional logic needed to make them to work.\nimport { Capability, K8s, Log, a, kind } from \"pepr\"; import { Gateway } from \"../crds/gateway-v1beta1\"; import { PurpleDestination, VirtualService, } from \"../crds/virtualservice-v1beta1\"; export const IstioVirtualService = new Capability({ name: \"istio-virtual-service\", description: \"Generate Istio VirtualService resources\", }); // Use the 'When' function to create a new action const { When, Store } = IstioVirtualService; // Define the configuration keys enum config { Gateway = \"uds/istio-gateway\", Host = \"uds/istio-host\", Port = \"uds/istio-port\", Domain = \"uds/istio-domain\", } // Define the valid gateway names const validGateway = [\"admin\", \"tenant\", \"passthrough\"]; // Watch Gateways to get the HTTPS domain for each gateway When(Gateway) .IsCreatedOrUpdated() .WithLabel(config.Domain) .Watch(vs =\u003e { // Store the domain for the gateway Store.setItem(vs.metadata.name, vs.metadata.labels[config.Domain]); }); ","categories":"","description":"","excerpt":"The Kubernetes Fluent Client supports the creation of TypeScript …","ref":"/main/customresources/","tags":"","title":"Importing Custom Resources"},{"body":"The Kubernetes Fluent Client supports the creation of TypeScript typings directly from Kubernetes Custom Resource Definitions (CRDs). The files it generates can be directly incorporated into Pepr capabilities and provide a way to work with strongly-typed CRDs.\nFor example (below), Istio CRDs can be imported and used as though they were intrinsic Kubernetes resources.\nGenerating TypeScript Types from CRDs Using the kubernetes-fluent-client to produce a new type looks like this:\nnpx kubernetes-fluent-client crd [source] [directory] The crd command expects a [source], which can be a URL or local file containing the CustomResourceDefinition(s), and a [directory] where the generated code will live.\nThe following example creates types for the Istio CRDs:\nuser@workstation$ npx kubernetes-fluent-client crd https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml crds Attempting to load https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml as a URL - Generating extensions.istio.io/v1alpha1 types for WasmPlugin - Generating networking.istio.io/v1alpha3 types for DestinationRule - Generating networking.istio.io/v1beta1 types for DestinationRule - Generating networking.istio.io/v1alpha3 types for EnvoyFilter - Generating networking.istio.io/v1alpha3 types for Gateway - Generating networking.istio.io/v1beta1 types for Gateway - Generating networking.istio.io/v1beta1 types for ProxyConfig - Generating networking.istio.io/v1alpha3 types for ServiceEntry - Generating networking.istio.io/v1beta1 types for ServiceEntry - Generating networking.istio.io/v1alpha3 types for Sidecar - Generating networking.istio.io/v1beta1 types for Sidecar - Generating networking.istio.io/v1alpha3 types for VirtualService - Generating networking.istio.io/v1beta1 types for VirtualService - Generating networking.istio.io/v1alpha3 types for WorkloadEntry - Generating networking.istio.io/v1beta1 types for WorkloadEntry - Generating networking.istio.io/v1alpha3 types for WorkloadGroup - Generating networking.istio.io/v1beta1 types for WorkloadGroup - Generating security.istio.io/v1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for PeerAuthentication - Generating security.istio.io/v1 types for RequestAuthentication - Generating security.istio.io/v1beta1 types for RequestAuthentication - Generating telemetry.istio.io/v1alpha1 types for Telemetry ✅ Generated 23 files in the istio directory Observe that the kubernetes-fluent-client has produced the TypeScript types within the crds directory. These types can now be utilized in the Pepr module.\nuser@workstation$ cat crds/proxyconfig-v1beta1.ts // This file is auto-generated by kubernetes-fluent-client, do not edit manually import { GenericKind, RegisterKind } from \"kubernetes-fluent-client\"; export class ProxyConfig extends GenericKind { /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ spec?: Spec; status?: { [key: string]: any }; } /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ export interface Spec { /** * The number of worker threads to run. */ concurrency?: number; /** * Additional environment variables for the proxy. */ environmentVariables?: { [key: string]: string }; /** * Specifies the details of the proxy image. */ image?: Image; /** * Optional. */ selector?: Selector; } /** * Specifies the details of the proxy image. */ export interface Image { /** * The image type of the image. */ imageType?: string; } /** * Optional. */ export interface Selector { /** * One or more labels that indicate a specific set of pods/VMs on which a policy should be * applied. */ matchLabels?: { [key: string]: string }; } RegisterKind(ProxyConfig, { group: \"networking.istio.io\", version: \"v1beta1\", kind: \"ProxyConfig\", }); Using new types The generated types can be imported into Pepr directly, there is no additional logic needed to make them to work.\nimport { Capability, K8s, Log, a, kind } from \"pepr\"; import { Gateway } from \"../crds/gateway-v1beta1\"; import { PurpleDestination, VirtualService, } from \"../crds/virtualservice-v1beta1\"; export const IstioVirtualService = new Capability({ name: \"istio-virtual-service\", description: \"Generate Istio VirtualService resources\", }); // Use the 'When' function to create a new action const { When, Store } = IstioVirtualService; // Define the configuration keys enum config { Gateway = \"uds/istio-gateway\", Host = \"uds/istio-host\", Port = \"uds/istio-port\", Domain = \"uds/istio-domain\", } // Define the valid gateway names const validGateway = [\"admin\", \"tenant\", \"passthrough\"]; // Watch Gateways to get the HTTPS domain for each gateway When(Gateway) .IsCreatedOrUpdated() .WithLabel(config.Domain) .Watch(vs =\u003e { // Store the domain for the gateway Store.setItem(vs.metadata.name, vs.metadata.labels[config.Domain]); }); ","categories":"","description":"","excerpt":"The Kubernetes Fluent Client supports the creation of TypeScript …","ref":"/v0.19.0/customresources/","tags":"","title":"Importing Custom Resources"},{"body":"The Kubernetes Fluent Client supports the creation of TypeScript typings directly from Kubernetes Custom Resource Definitions (CRDs). The files it generates can be directly incorporated into Pepr capabilities and provide a way to work with strongly-typed CRDs.\nFor example (below), Istio CRDs can be imported and used as though they were intrinsic Kubernetes resources.\nGenerating TypeScript Types from CRDs Using the kubernetes-fluent-client to produce a new type looks like this:\nnpx kubernetes-fluent-client crd [source] [directory] The crd command expects a [source], which can be a URL or local file containing the CustomResourceDefinition(s), and a [directory] where the generated code will live.\nThe following example creates types for the Istio CRDs:\nuser@workstation$ npx kubernetes-fluent-client crd https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml crds Attempting to load https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml as a URL - Generating extensions.istio.io/v1alpha1 types for WasmPlugin - Generating networking.istio.io/v1alpha3 types for DestinationRule - Generating networking.istio.io/v1beta1 types for DestinationRule - Generating networking.istio.io/v1alpha3 types for EnvoyFilter - Generating networking.istio.io/v1alpha3 types for Gateway - Generating networking.istio.io/v1beta1 types for Gateway - Generating networking.istio.io/v1beta1 types for ProxyConfig - Generating networking.istio.io/v1alpha3 types for ServiceEntry - Generating networking.istio.io/v1beta1 types for ServiceEntry - Generating networking.istio.io/v1alpha3 types for Sidecar - Generating networking.istio.io/v1beta1 types for Sidecar - Generating networking.istio.io/v1alpha3 types for VirtualService - Generating networking.istio.io/v1beta1 types for VirtualService - Generating networking.istio.io/v1alpha3 types for WorkloadEntry - Generating networking.istio.io/v1beta1 types for WorkloadEntry - Generating networking.istio.io/v1alpha3 types for WorkloadGroup - Generating networking.istio.io/v1beta1 types for WorkloadGroup - Generating security.istio.io/v1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for PeerAuthentication - Generating security.istio.io/v1 types for RequestAuthentication - Generating security.istio.io/v1beta1 types for RequestAuthentication - Generating telemetry.istio.io/v1alpha1 types for Telemetry ✅ Generated 23 files in the istio directory Observe that the kubernetes-fluent-client has produced the TypeScript types within the crds directory. These types can now be utilized in the Pepr module.\nuser@workstation$ cat crds/proxyconfig-v1beta1.ts // This file is auto-generated by kubernetes-fluent-client, do not edit manually import { GenericKind, RegisterKind } from \"kubernetes-fluent-client\"; export class ProxyConfig extends GenericKind { /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ spec?: Spec; status?: { [key: string]: any }; } /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ export interface Spec { /** * The number of worker threads to run. */ concurrency?: number; /** * Additional environment variables for the proxy. */ environmentVariables?: { [key: string]: string }; /** * Specifies the details of the proxy image. */ image?: Image; /** * Optional. */ selector?: Selector; } /** * Specifies the details of the proxy image. */ export interface Image { /** * The image type of the image. */ imageType?: string; } /** * Optional. */ export interface Selector { /** * One or more labels that indicate a specific set of pods/VMs on which a policy should be * applied. */ matchLabels?: { [key: string]: string }; } RegisterKind(ProxyConfig, { group: \"networking.istio.io\", version: \"v1beta1\", kind: \"ProxyConfig\", }); Using new types The generated types can be imported into Pepr directly, there is no additional logic needed to make them to work.\nimport { Capability, K8s, Log, a, kind } from \"pepr\"; import { Gateway } from \"../crds/gateway-v1beta1\"; import { PurpleDestination, VirtualService, } from \"../crds/virtualservice-v1beta1\"; export const IstioVirtualService = new Capability({ name: \"istio-virtual-service\", description: \"Generate Istio VirtualService resources\", }); // Use the 'When' function to create a new action const { When, Store } = IstioVirtualService; // Define the configuration keys enum config { Gateway = \"uds/istio-gateway\", Host = \"uds/istio-host\", Port = \"uds/istio-port\", Domain = \"uds/istio-domain\", } // Define the valid gateway names const validGateway = [\"admin\", \"tenant\", \"passthrough\"]; // Watch Gateways to get the HTTPS domain for each gateway When(Gateway) .IsCreatedOrUpdated() .WithLabel(config.Domain) .Watch(vs =\u003e { // Store the domain for the gateway Store.setItem(vs.metadata.name, vs.metadata.labels[config.Domain]); }); ","categories":"","description":"","excerpt":"The Kubernetes Fluent Client supports the creation of TypeScript …","ref":"/v0.20.0/customresources/","tags":"","title":"Importing Custom Resources"},{"body":"The Kubernetes Fluent Client supports the creation of TypeScript typings directly from Kubernetes Custom Resource Definitions (CRDs). The files it generates can be directly incorporated into Pepr capabilities and provide a way to work with strongly-typed CRDs.\nFor example (below), Istio CRDs can be imported and used as though they were intrinsic Kubernetes resources.\nGenerating TypeScript Types from CRDs Using the kubernetes-fluent-client to produce a new type looks like this:\nnpx kubernetes-fluent-client crd [source] [directory] The crd command expects a [source], which can be a URL or local file containing the CustomResourceDefinition(s), and a [directory] where the generated code will live.\nThe following example creates types for the Istio CRDs:\nuser@workstation$ npx kubernetes-fluent-client crd https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml crds Attempting to load https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml as a URL - Generating extensions.istio.io/v1alpha1 types for WasmPlugin - Generating networking.istio.io/v1alpha3 types for DestinationRule - Generating networking.istio.io/v1beta1 types for DestinationRule - Generating networking.istio.io/v1alpha3 types for EnvoyFilter - Generating networking.istio.io/v1alpha3 types for Gateway - Generating networking.istio.io/v1beta1 types for Gateway - Generating networking.istio.io/v1beta1 types for ProxyConfig - Generating networking.istio.io/v1alpha3 types for ServiceEntry - Generating networking.istio.io/v1beta1 types for ServiceEntry - Generating networking.istio.io/v1alpha3 types for Sidecar - Generating networking.istio.io/v1beta1 types for Sidecar - Generating networking.istio.io/v1alpha3 types for VirtualService - Generating networking.istio.io/v1beta1 types for VirtualService - Generating networking.istio.io/v1alpha3 types for WorkloadEntry - Generating networking.istio.io/v1beta1 types for WorkloadEntry - Generating networking.istio.io/v1alpha3 types for WorkloadGroup - Generating networking.istio.io/v1beta1 types for WorkloadGroup - Generating security.istio.io/v1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for PeerAuthentication - Generating security.istio.io/v1 types for RequestAuthentication - Generating security.istio.io/v1beta1 types for RequestAuthentication - Generating telemetry.istio.io/v1alpha1 types for Telemetry ✅ Generated 23 files in the istio directory Observe that the kubernetes-fluent-client has produced the TypeScript types within the crds directory. These types can now be utilized in the Pepr module.\nuser@workstation$ cat crds/proxyconfig-v1beta1.ts // This file is auto-generated by kubernetes-fluent-client, do not edit manually import { GenericKind, RegisterKind } from \"kubernetes-fluent-client\"; export class ProxyConfig extends GenericKind { /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ spec?: Spec; status?: { [key: string]: any }; } /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ export interface Spec { /** * The number of worker threads to run. */ concurrency?: number; /** * Additional environment variables for the proxy. */ environmentVariables?: { [key: string]: string }; /** * Specifies the details of the proxy image. */ image?: Image; /** * Optional. */ selector?: Selector; } /** * Specifies the details of the proxy image. */ export interface Image { /** * The image type of the image. */ imageType?: string; } /** * Optional. */ export interface Selector { /** * One or more labels that indicate a specific set of pods/VMs on which a policy should be * applied. */ matchLabels?: { [key: string]: string }; } RegisterKind(ProxyConfig, { group: \"networking.istio.io\", version: \"v1beta1\", kind: \"ProxyConfig\", }); Using new types The generated types can be imported into Pepr directly, there is no additional logic needed to make them to work.\nimport { Capability, K8s, Log, a, kind } from \"pepr\"; import { Gateway } from \"../crds/gateway-v1beta1\"; import { PurpleDestination, VirtualService, } from \"../crds/virtualservice-v1beta1\"; export const IstioVirtualService = new Capability({ name: \"istio-virtual-service\", description: \"Generate Istio VirtualService resources\", }); // Use the 'When' function to create a new action const { When, Store } = IstioVirtualService; // Define the configuration keys enum config { Gateway = \"uds/istio-gateway\", Host = \"uds/istio-host\", Port = \"uds/istio-port\", Domain = \"uds/istio-domain\", } // Define the valid gateway names const validGateway = [\"admin\", \"tenant\", \"passthrough\"]; // Watch Gateways to get the HTTPS domain for each gateway When(Gateway) .IsCreatedOrUpdated() .WithLabel(config.Domain) .Watch(vs =\u003e { // Store the domain for the gateway Store.setItem(vs.metadata.name, vs.metadata.labels[config.Domain]); }); ","categories":"","description":"","excerpt":"The Kubernetes Fluent Client supports the creation of TypeScript …","ref":"/v0.20.1/customresources/","tags":"","title":"Importing Custom Resources"},{"body":"The Kubernetes Fluent Client supports the creation of TypeScript typings directly from Kubernetes Custom Resource Definitions (CRDs). The files it generates can be directly incorporated into Pepr capabilities and provide a way to work with strongly-typed CRDs.\nFor example (below), Istio CRDs can be imported and used as though they were intrinsic Kubernetes resources.\nGenerating TypeScript Types from CRDs Using the kubernetes-fluent-client to produce a new type looks like this:\nnpx kubernetes-fluent-client crd [source] [directory] The crd command expects a [source], which can be a URL or local file containing the CustomResourceDefinition(s), and a [directory] where the generated code will live.\nThe following example creates types for the Istio CRDs:\nuser@workstation$ npx kubernetes-fluent-client crd https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml crds Attempting to load https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml as a URL - Generating extensions.istio.io/v1alpha1 types for WasmPlugin - Generating networking.istio.io/v1alpha3 types for DestinationRule - Generating networking.istio.io/v1beta1 types for DestinationRule - Generating networking.istio.io/v1alpha3 types for EnvoyFilter - Generating networking.istio.io/v1alpha3 types for Gateway - Generating networking.istio.io/v1beta1 types for Gateway - Generating networking.istio.io/v1beta1 types for ProxyConfig - Generating networking.istio.io/v1alpha3 types for ServiceEntry - Generating networking.istio.io/v1beta1 types for ServiceEntry - Generating networking.istio.io/v1alpha3 types for Sidecar - Generating networking.istio.io/v1beta1 types for Sidecar - Generating networking.istio.io/v1alpha3 types for VirtualService - Generating networking.istio.io/v1beta1 types for VirtualService - Generating networking.istio.io/v1alpha3 types for WorkloadEntry - Generating networking.istio.io/v1beta1 types for WorkloadEntry - Generating networking.istio.io/v1alpha3 types for WorkloadGroup - Generating networking.istio.io/v1beta1 types for WorkloadGroup - Generating security.istio.io/v1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for PeerAuthentication - Generating security.istio.io/v1 types for RequestAuthentication - Generating security.istio.io/v1beta1 types for RequestAuthentication - Generating telemetry.istio.io/v1alpha1 types for Telemetry ✅ Generated 23 files in the istio directory Observe that the kubernetes-fluent-client has produced the TypeScript types within the crds directory. These types can now be utilized in the Pepr module.\nuser@workstation$ cat crds/proxyconfig-v1beta1.ts // This file is auto-generated by kubernetes-fluent-client, do not edit manually import { GenericKind, RegisterKind } from \"kubernetes-fluent-client\"; export class ProxyConfig extends GenericKind { /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ spec?: Spec; status?: { [key: string]: any }; } /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ export interface Spec { /** * The number of worker threads to run. */ concurrency?: number; /** * Additional environment variables for the proxy. */ environmentVariables?: { [key: string]: string }; /** * Specifies the details of the proxy image. */ image?: Image; /** * Optional. */ selector?: Selector; } /** * Specifies the details of the proxy image. */ export interface Image { /** * The image type of the image. */ imageType?: string; } /** * Optional. */ export interface Selector { /** * One or more labels that indicate a specific set of pods/VMs on which a policy should be * applied. */ matchLabels?: { [key: string]: string }; } RegisterKind(ProxyConfig, { group: \"networking.istio.io\", version: \"v1beta1\", kind: \"ProxyConfig\", }); Using new types The generated types can be imported into Pepr directly, there is no additional logic needed to make them to work.\nimport { Capability, K8s, Log, a, kind } from \"pepr\"; import { Gateway } from \"../crds/gateway-v1beta1\"; import { PurpleDestination, VirtualService, } from \"../crds/virtualservice-v1beta1\"; export const IstioVirtualService = new Capability({ name: \"istio-virtual-service\", description: \"Generate Istio VirtualService resources\", }); // Use the 'When' function to create a new action const { When, Store } = IstioVirtualService; // Define the configuration keys enum config { Gateway = \"uds/istio-gateway\", Host = \"uds/istio-host\", Port = \"uds/istio-port\", Domain = \"uds/istio-domain\", } // Define the valid gateway names const validGateway = [\"admin\", \"tenant\", \"passthrough\"]; // Watch Gateways to get the HTTPS domain for each gateway When(Gateway) .IsCreatedOrUpdated() .WithLabel(config.Domain) .Watch(vs =\u003e { // Store the domain for the gateway Store.setItem(vs.metadata.name, vs.metadata.labels[config.Domain]); }); ","categories":"","description":"","excerpt":"The Kubernetes Fluent Client supports the creation of TypeScript …","ref":"/v0.20.2/customresources/","tags":"","title":"Importing Custom Resources"},{"body":"The Kubernetes Fluent Client supports the creation of TypeScript typings directly from Kubernetes Custom Resource Definitions (CRDs). The files it generates can be directly incorporated into Pepr capabilities and provide a way to work with strongly-typed CRDs.\nFor example (below), Istio CRDs can be imported and used as though they were intrinsic Kubernetes resources.\nGenerating TypeScript Types from CRDs Using the kubernetes-fluent-client to produce a new type looks like this:\nnpx kubernetes-fluent-client crd [source] [directory] The crd command expects a [source], which can be a URL or local file containing the CustomResourceDefinition(s), and a [directory] where the generated code will live.\nThe following example creates types for the Istio CRDs:\nuser@workstation$ npx kubernetes-fluent-client crd https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml crds Attempting to load https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml as a URL - Generating extensions.istio.io/v1alpha1 types for WasmPlugin - Generating networking.istio.io/v1alpha3 types for DestinationRule - Generating networking.istio.io/v1beta1 types for DestinationRule - Generating networking.istio.io/v1alpha3 types for EnvoyFilter - Generating networking.istio.io/v1alpha3 types for Gateway - Generating networking.istio.io/v1beta1 types for Gateway - Generating networking.istio.io/v1beta1 types for ProxyConfig - Generating networking.istio.io/v1alpha3 types for ServiceEntry - Generating networking.istio.io/v1beta1 types for ServiceEntry - Generating networking.istio.io/v1alpha3 types for Sidecar - Generating networking.istio.io/v1beta1 types for Sidecar - Generating networking.istio.io/v1alpha3 types for VirtualService - Generating networking.istio.io/v1beta1 types for VirtualService - Generating networking.istio.io/v1alpha3 types for WorkloadEntry - Generating networking.istio.io/v1beta1 types for WorkloadEntry - Generating networking.istio.io/v1alpha3 types for WorkloadGroup - Generating networking.istio.io/v1beta1 types for WorkloadGroup - Generating security.istio.io/v1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for PeerAuthentication - Generating security.istio.io/v1 types for RequestAuthentication - Generating security.istio.io/v1beta1 types for RequestAuthentication - Generating telemetry.istio.io/v1alpha1 types for Telemetry ✅ Generated 23 files in the istio directory Observe that the kubernetes-fluent-client has produced the TypeScript types within the crds directory. These types can now be utilized in the Pepr module.\nuser@workstation$ cat crds/proxyconfig-v1beta1.ts // This file is auto-generated by kubernetes-fluent-client, do not edit manually import { GenericKind, RegisterKind } from \"kubernetes-fluent-client\"; export class ProxyConfig extends GenericKind { /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ spec?: Spec; status?: { [key: string]: any }; } /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ export interface Spec { /** * The number of worker threads to run. */ concurrency?: number; /** * Additional environment variables for the proxy. */ environmentVariables?: { [key: string]: string }; /** * Specifies the details of the proxy image. */ image?: Image; /** * Optional. */ selector?: Selector; } /** * Specifies the details of the proxy image. */ export interface Image { /** * The image type of the image. */ imageType?: string; } /** * Optional. */ export interface Selector { /** * One or more labels that indicate a specific set of pods/VMs on which a policy should be * applied. */ matchLabels?: { [key: string]: string }; } RegisterKind(ProxyConfig, { group: \"networking.istio.io\", version: \"v1beta1\", kind: \"ProxyConfig\", }); Using new types The generated types can be imported into Pepr directly, there is no additional logic needed to make them to work.\nimport { Capability, K8s, Log, a, kind } from \"pepr\"; import { Gateway } from \"../crds/gateway-v1beta1\"; import { PurpleDestination, VirtualService, } from \"../crds/virtualservice-v1beta1\"; export const IstioVirtualService = new Capability({ name: \"istio-virtual-service\", description: \"Generate Istio VirtualService resources\", }); // Use the 'When' function to create a new action const { When, Store } = IstioVirtualService; // Define the configuration keys enum config { Gateway = \"uds/istio-gateway\", Host = \"uds/istio-host\", Port = \"uds/istio-port\", Domain = \"uds/istio-domain\", } // Define the valid gateway names const validGateway = [\"admin\", \"tenant\", \"passthrough\"]; // Watch Gateways to get the HTTPS domain for each gateway When(Gateway) .IsCreatedOrUpdated() .WithLabel(config.Domain) .Watch(vs =\u003e { // Store the domain for the gateway Store.setItem(vs.metadata.name, vs.metadata.labels[config.Domain]); }); ","categories":"","description":"","excerpt":"The Kubernetes Fluent Client supports the creation of TypeScript …","ref":"/v0.20.3/customresources/","tags":"","title":"Importing Custom Resources"},{"body":"The Kubernetes Fluent Client supports the creation of TypeScript typings directly from Kubernetes Custom Resource Definitions (CRDs). The files it generates can be directly incorporated into Pepr capabilities and provide a way to work with strongly-typed CRDs.\nFor example (below), Istio CRDs can be imported and used as though they were intrinsic Kubernetes resources.\nGenerating TypeScript Types from CRDs Using the kubernetes-fluent-client to produce a new type looks like this:\nnpx kubernetes-fluent-client crd [source] [directory] The crd command expects a [source], which can be a URL or local file containing the CustomResourceDefinition(s), and a [directory] where the generated code will live.\nThe following example creates types for the Istio CRDs:\nuser@workstation$ npx kubernetes-fluent-client crd https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml crds Attempting to load https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml as a URL - Generating extensions.istio.io/v1alpha1 types for WasmPlugin - Generating networking.istio.io/v1alpha3 types for DestinationRule - Generating networking.istio.io/v1beta1 types for DestinationRule - Generating networking.istio.io/v1alpha3 types for EnvoyFilter - Generating networking.istio.io/v1alpha3 types for Gateway - Generating networking.istio.io/v1beta1 types for Gateway - Generating networking.istio.io/v1beta1 types for ProxyConfig - Generating networking.istio.io/v1alpha3 types for ServiceEntry - Generating networking.istio.io/v1beta1 types for ServiceEntry - Generating networking.istio.io/v1alpha3 types for Sidecar - Generating networking.istio.io/v1beta1 types for Sidecar - Generating networking.istio.io/v1alpha3 types for VirtualService - Generating networking.istio.io/v1beta1 types for VirtualService - Generating networking.istio.io/v1alpha3 types for WorkloadEntry - Generating networking.istio.io/v1beta1 types for WorkloadEntry - Generating networking.istio.io/v1alpha3 types for WorkloadGroup - Generating networking.istio.io/v1beta1 types for WorkloadGroup - Generating security.istio.io/v1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for PeerAuthentication - Generating security.istio.io/v1 types for RequestAuthentication - Generating security.istio.io/v1beta1 types for RequestAuthentication - Generating telemetry.istio.io/v1alpha1 types for Telemetry ✅ Generated 23 files in the istio directory Observe that the kubernetes-fluent-client has produced the TypeScript types within the crds directory. These types can now be utilized in the Pepr module.\nuser@workstation$ cat crds/proxyconfig-v1beta1.ts // This file is auto-generated by kubernetes-fluent-client, do not edit manually import { GenericKind, RegisterKind } from \"kubernetes-fluent-client\"; export class ProxyConfig extends GenericKind { /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ spec?: Spec; status?: { [key: string]: any }; } /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ export interface Spec { /** * The number of worker threads to run. */ concurrency?: number; /** * Additional environment variables for the proxy. */ environmentVariables?: { [key: string]: string }; /** * Specifies the details of the proxy image. */ image?: Image; /** * Optional. */ selector?: Selector; } /** * Specifies the details of the proxy image. */ export interface Image { /** * The image type of the image. */ imageType?: string; } /** * Optional. */ export interface Selector { /** * One or more labels that indicate a specific set of pods/VMs on which a policy should be * applied. */ matchLabels?: { [key: string]: string }; } RegisterKind(ProxyConfig, { group: \"networking.istio.io\", version: \"v1beta1\", kind: \"ProxyConfig\", }); Using new types The generated types can be imported into Pepr directly, there is no additional logic needed to make them to work.\nimport { Capability, K8s, Log, a, kind } from \"pepr\"; import { Gateway } from \"../crds/gateway-v1beta1\"; import { PurpleDestination, VirtualService, } from \"../crds/virtualservice-v1beta1\"; export const IstioVirtualService = new Capability({ name: \"istio-virtual-service\", description: \"Generate Istio VirtualService resources\", }); // Use the 'When' function to create a new action const { When, Store } = IstioVirtualService; // Define the configuration keys enum config { Gateway = \"uds/istio-gateway\", Host = \"uds/istio-host\", Port = \"uds/istio-port\", Domain = \"uds/istio-domain\", } // Define the valid gateway names const validGateway = [\"admin\", \"tenant\", \"passthrough\"]; // Watch Gateways to get the HTTPS domain for each gateway When(Gateway) .IsCreatedOrUpdated() .WithLabel(config.Domain) .Watch(vs =\u003e { // Store the domain for the gateway Store.setItem(vs.metadata.name, vs.metadata.labels[config.Domain]); }); ","categories":"","description":"","excerpt":"The Kubernetes Fluent Client supports the creation of TypeScript …","ref":"/v0.21.0/customresources/","tags":"","title":"Importing Custom Resources"},{"body":"The Kubernetes Fluent Client supports the creation of TypeScript typings directly from Kubernetes Custom Resource Definitions (CRDs). The files it generates can be directly incorporated into Pepr capabilities and provide a way to work with strongly-typed CRDs.\nFor example (below), Istio CRDs can be imported and used as though they were intrinsic Kubernetes resources.\nGenerating TypeScript Types from CRDs Using the kubernetes-fluent-client to produce a new type looks like this:\nnpx kubernetes-fluent-client crd [source] [directory] The crd command expects a [source], which can be a URL or local file containing the CustomResourceDefinition(s), and a [directory] where the generated code will live.\nThe following example creates types for the Istio CRDs:\nuser@workstation$ npx kubernetes-fluent-client crd https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml crds Attempting to load https://raw.githubusercontent.com/istio/istio/master/manifests/charts/base/crds/crd-all.gen.yaml as a URL - Generating extensions.istio.io/v1alpha1 types for WasmPlugin - Generating networking.istio.io/v1alpha3 types for DestinationRule - Generating networking.istio.io/v1beta1 types for DestinationRule - Generating networking.istio.io/v1alpha3 types for EnvoyFilter - Generating networking.istio.io/v1alpha3 types for Gateway - Generating networking.istio.io/v1beta1 types for Gateway - Generating networking.istio.io/v1beta1 types for ProxyConfig - Generating networking.istio.io/v1alpha3 types for ServiceEntry - Generating networking.istio.io/v1beta1 types for ServiceEntry - Generating networking.istio.io/v1alpha3 types for Sidecar - Generating networking.istio.io/v1beta1 types for Sidecar - Generating networking.istio.io/v1alpha3 types for VirtualService - Generating networking.istio.io/v1beta1 types for VirtualService - Generating networking.istio.io/v1alpha3 types for WorkloadEntry - Generating networking.istio.io/v1beta1 types for WorkloadEntry - Generating networking.istio.io/v1alpha3 types for WorkloadGroup - Generating networking.istio.io/v1beta1 types for WorkloadGroup - Generating security.istio.io/v1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for AuthorizationPolicy - Generating security.istio.io/v1beta1 types for PeerAuthentication - Generating security.istio.io/v1 types for RequestAuthentication - Generating security.istio.io/v1beta1 types for RequestAuthentication - Generating telemetry.istio.io/v1alpha1 types for Telemetry ✅ Generated 23 files in the istio directory Observe that the kubernetes-fluent-client has produced the TypeScript types within the crds directory. These types can now be utilized in the Pepr module.\nuser@workstation$ cat crds/proxyconfig-v1beta1.ts // This file is auto-generated by kubernetes-fluent-client, do not edit manually import { GenericKind, RegisterKind } from \"kubernetes-fluent-client\"; export class ProxyConfig extends GenericKind { /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ spec?: Spec; status?: { [key: string]: any }; } /** * Provides configuration for individual workloads. See more details at: * https://istio.io/docs/reference/config/networking/proxy-config.html */ export interface Spec { /** * The number of worker threads to run. */ concurrency?: number; /** * Additional environment variables for the proxy. */ environmentVariables?: { [key: string]: string }; /** * Specifies the details of the proxy image. */ image?: Image; /** * Optional. */ selector?: Selector; } /** * Specifies the details of the proxy image. */ export interface Image { /** * The image type of the image. */ imageType?: string; } /** * Optional. */ export interface Selector { /** * One or more labels that indicate a specific set of pods/VMs on which a policy should be * applied. */ matchLabels?: { [key: string]: string }; } RegisterKind(ProxyConfig, { group: \"networking.istio.io\", version: \"v1beta1\", kind: \"ProxyConfig\", }); Using new types The generated types can be imported into Pepr directly, there is no additional logic needed to make them to work.\nimport { Capability, K8s, Log, a, kind } from \"pepr\"; import { Gateway } from \"../crds/gateway-v1beta1\"; import { PurpleDestination, VirtualService, } from \"../crds/virtualservice-v1beta1\"; export const IstioVirtualService = new Capability({ name: \"istio-virtual-service\", description: \"Generate Istio VirtualService resources\", }); // Use the 'When' function to create a new action const { When, Store } = IstioVirtualService; // Define the configuration keys enum config { Gateway = \"uds/istio-gateway\", Host = \"uds/istio-host\", Port = \"uds/istio-port\", Domain = \"uds/istio-domain\", } // Define the valid gateway names const validGateway = [\"admin\", \"tenant\", \"passthrough\"]; // Watch Gateways to get the HTTPS domain for each gateway When(Gateway) .IsCreatedOrUpdated() .WithLabel(config.Domain) .Watch(vs =\u003e { // Store the domain for the gateway Store.setItem(vs.metadata.name, vs.metadata.labels[config.Domain]); }); ","categories":"","description":"","excerpt":"The Kubernetes Fluent Client supports the creation of TypeScript …","ref":"/v0.21.1/customresources/","tags":"","title":"Importing Custom Resources"},{"body":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission to save Kubernetes from the tyranny of YAML, intimidating glue code, bash scripts, and other makeshift solutions. As a Kubernetes controller, Pepr empowers you to define Kubernetes transformations using TypeScript, without software development expertise thanks to plain-english configurations. Pepr transforms a patchwork of forks, scripts, overlays, and other chaos into a cohesive, well-structured, and maintainable system. With Pepr, you can seamlessly transition IT ops tribal knowledge into code, simplifying documentation, testing, validation, and coordination of changes for a more predictable outcome.\nNote: Pepr is still in active development so breaking changes may occur, but will be documented in release notes. Features Zero-config K8s webhook mutations and validations Automatic leader-elected K8s resource watching Lightweight async key-value store backed by K8s for stateful operations with the Pepr Store Human-readable fluent API for generating Pepr Capabilities A fluent API for creating/modifying/watching and server-side applying K8s resources via Kubernetes Fluent Client Generate new K8s resources based off of cluster resource changes Perform other exec/API calls based off of cluster resources changes or any other arbitrary schedule Out of the box airgap support with Zarf Entire NPM ecosystem available for advanced operations Realtime K8s debugging system for testing/reacting to cluster changes Controller network isolation and tamper-resistent module execution Least-privilege RBAC generation AMD64 and ARM64 support Example Pepr Action This quick sample shows how to react to a ConfigMap being created or updated in the cluster. It adds a label and annotation to the ConfigMap and adds some data to the ConfigMap. It also creates a Validating Webhook to make sure the “pepr” label still exists. Finally, after the ConfigMap is created, it logs a message to the Pepr controller and creates or updates a separate ConfigMap with the kubernetes-fluent-client using server-side apply. For more details see actions section.\nWhen(a.ConfigMap) .IsCreatedOrUpdated() .InNamespace(\"pepr-demo\") .WithLabel(\"unicorn\", \"rainbow\") // Create a Mutate Action for the ConfigMap .Mutate(request =\u003e { // Add a label and annotation to the ConfigMap request.SetLabel(\"pepr\", \"was-here\").SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Add some data to the ConfigMap request.Raw.data[\"doug-says\"] = \"Pepr is awesome!\"; // Log a message to the Pepr controller logs Log.info(\"A 🦄 ConfigMap was created or updated:\"); }) // Create a Validate Action for the ConfigMap .Validate(request =\u003e { // Validate the ConfigMap has a specific label if (request.HasLabel(\"pepr\")) { return request.Approve(); } // Reject the ConfigMap if it doesn't have the label return request.Deny(\"ConfigMap must have a unicorn label\"); }) // Watch behaves like controller-runtime's Manager.Watch() .Watch(async (cm, phase) =\u003e { Log.info(cm, `ConfigMap was ${phase}.`); // Apply a ConfigMap using K8s server-side apply (will create or update) await K8s(kind.ConfigMap).Apply({ metadata: { name: \"pepr-ssa-demo\", namespace: \"pepr-demo-2\", }, data: { uid: cm.metadata.uid, }, }); }); Prerequisites Node.js v18.0.0+ (even-numbered releases only)\nTo ensure compatability and optimal performance, it is recommended to use even-numbered releases of Node.js as they are stable releases and receive long-term support for three years. Odd-numbered releases are experimental and may not be supported by certain libraries utilized in Pepr. npm v10.1.0+\nRecommended (optional) tools:\nVisual Studio Code for inline debugging and Pepr Capabilities creation. A Kubernetes cluster for npx pepr dev. Pepr modules include npm run k3d-setup if you want to test locally with K3d and Docker. Wow too many words! tl;dr; # Create a new Pepr Module npx pepr init # If you already have a Kind or K3d cluster you want to use, skip this step npm run k3d-setup # Start playing with Pepr now # If using another local K8s distro instead of k3d, run `npx pepr dev --host host.docker.internal` npx pepr dev kubectl apply -f capabilities/hello-pepr.samples.yaml # Be amazed and ⭐️ this repo Concepts Module A module is the top-level collection of capabilities. It is a single, complete TypeScript project that includes an entry point to load all the configuration and capabilities, along with their actions. During the Pepr build process, each module produces a unique Kubernetes MutatingWebhookConfiguration and ValidatingWebhookConfiguration, along with a secret containing the transpiled and compressed TypeScript code. The webhooks and secret are deployed into the Kubernetes cluster with their own isolated controller.\nSee Module for more details.\nCapability A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nSee Capabilities for more details.\nAction Action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in from Kubernetes. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nThere are both Mutate() and Validate() Actions that can be used to modify or validate Kubernetes resources within the admission controller lifecycle. There is also a Watch() Action that can be used to watch for changes to Kubernetes resources that already exist.\nSee actions for more details.\nLogical Pepr Flow Source Diagram\nTypeScript TypeScript is a strongly typed, object-oriented programming language built on top of JavaScript. It provides optional static typing and a rich type system, allowing developers to write more robust code. TypeScript is transpiled to JavaScript, enabling it to run in any environment that supports JavaScript. Pepr allows you to use JavaScript or TypeScript to write capabilities, but TypeScript is recommended for its type safety and rich type system. You can learn more about TypeScript here.\n","categories":"","description":"","excerpt":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission …","ref":"/main/","tags":"","title":"main"},{"body":"The OnSchedule feature allows you to schedule and automate the execution of specific code at predefined intervals or schedules. This feature is designed to simplify recurring tasks and can serve as an alternative to traditional CronJobs. This code is designed to be run at the top level on a Capability, not within a function like When.\nNote - To use this feature in dev mode you MUST set PEPR_WATCH_MODE=\"true\". This is because the scheduler only runs on the watch controller and the watch controller is not started by default in dev mode.\nFor example: PEPR_WATCH_MODE=\"true\" npx pepr dev\nBest Practices OnSchedule is designed for targeting intervals equal to or larger than 30 seconds due to the storage mechanism used to archive schedule info.\nUsage Create a recurring task execution by calling the OnSchedule function with the following parameters:\nname - The unique name of the schedule.\nevery - An integer that represents the frequency of the schedule in number of units.\nunit - A string specifying the time unit for the schedule (e.g., seconds, minute, minutes, hour, hours).\nstartTime - (Optional) A UTC timestamp indicating when the schedule should start. All date times must be provided in GMT. If not specified the schedule will start when the schedule store reports ready.\nrun - A function that contains the code you want to execute on the defined schedule.\ncompletions - (Optional) An integer indicating the maximum number of times the schedule should run to completion. If not specified the schedule will run indefinitely.\nExamples Update a ConfigMap every 30 seconds:\nOnSchedule({ name: \"hello-interval\", every: 30, unit: \"seconds\", run: async () =\u003e { Log.info(\"Wait 30 seconds and create/update a ConfigMap\"); try { await K8s(kind.ConfigMap).Apply({ metadata: { name: \"last-updated\", namespace: \"default\", }, data: { count: `${new Date()}`, }, }); } catch (error) { Log.error(error, \"Failed to apply ConfigMap using server-side apply.\"); } }, }); Refresh an AWSToken every 24 hours, with a delayed start of 30 seconds, running a total of 3 times:\nOnSchedule({ name: \"refresh-aws-token\", every: 24, unit: \"hours\", startTime: new Date(new Date().getTime() + 1000 * 30), run: async () =\u003e { await RefreshAWSToken(); }, completions: 3, }); Advantages Simplifies scheduling recurring tasks without the need for complex CronJob configurations. Provides flexibility to define schedules in a human-readable format. Allows you to execute code with precision at specified intervals. Supports limiting the number of schedule completions for finite tasks. ","categories":"","description":"","excerpt":"The OnSchedule feature allows you to schedule and automate the …","ref":"/main/onschedule/","tags":"","title":"OnSchedule"},{"body":"The OnSchedule feature allows you to schedule and automate the execution of specific code at predefined intervals or schedules. This feature is designed to simplify recurring tasks and can serve as an alternative to traditional CronJobs. This code is designed to be run at the top level on a Capability, not within a function like When.\nNote - To use this feature in dev mode you MUST set PEPR_WATCH_MODE=\"true\". This is because the scheduler only runs on the watch controller and the watch controller is not started by default in dev mode.\nFor example: PEPR_WATCH_MODE=\"true\" npx pepr dev\nBest Practices OnSchedule is designed for targeting intervals equal to or larger than 30 seconds due to the storage mechanism used to archive schedule info.\nUsage Create a recurring task execution by calling the OnSchedule function with the following parameters:\nname - The unique name of the schedule.\nevery - An integer that represents the frequency of the schedule in number of units.\nunit - A string specifying the time unit for the schedule (e.g., seconds, minute, minutes, hour, hours).\nstartTime - (Optional) A UTC timestamp indicating when the schedule should start. All date times must be provided in GMT. If not specified the schedule will start when the schedule store reports ready.\nrun - A function that contains the code you want to execute on the defined schedule.\ncompletions - (Optional) An integer indicating the maximum number of times the schedule should run to completion. If not specified the schedule will run indefinitely.\nExamples Update a ConfigMap every 30 seconds:\nOnSchedule({ name: \"hello-interval\", every: 30, unit: \"seconds\", run: async () =\u003e { Log.info(\"Wait 30 seconds and create/update a ConfigMap\"); try { await K8s(kind.ConfigMap).Apply({ metadata: { name: \"last-updated\", namespace: \"default\", }, data: { count: `${new Date()}`, }, }); } catch (error) { Log.error(error, \"Failed to apply ConfigMap using server-side apply.\"); } }, }); Refresh an AWSToken every 24 hours, with a delayed start of 30 seconds, running a total of 3 times:\nOnSchedule({ name: \"refresh-aws-token\", every: 24, unit: \"hours\", startTime: new Date(new Date().getTime() + 1000 * 30), run: async () =\u003e { await RefreshAWSToken(); }, completions: 3, }); Advantages Simplifies scheduling recurring tasks without the need for complex CronJob configurations. Provides flexibility to define schedules in a human-readable format. Allows you to execute code with precision at specified intervals. Supports limiting the number of schedule completions for finite tasks. ","categories":"","description":"","excerpt":"The OnSchedule feature allows you to schedule and automate the …","ref":"/v0.19.0/onschedule/","tags":"","title":"OnSchedule"},{"body":"The OnSchedule feature allows you to schedule and automate the execution of specific code at predefined intervals or schedules. This feature is designed to simplify recurring tasks and can serve as an alternative to traditional CronJobs. This code is designed to be run at the top level on a Capability, not within a function like When.\nNote - To use this feature in dev mode you MUST set PEPR_WATCH_MODE=\"true\". This is because the scheduler only runs on the watch controller and the watch controller is not started by default in dev mode.\nFor example: PEPR_WATCH_MODE=\"true\" npx pepr dev\nBest Practices OnSchedule is designed for targeting intervals equal to or larger than 30 seconds due to the storage mechanism used to archive schedule info.\nUsage Create a recurring task execution by calling the OnSchedule function with the following parameters:\nname - The unique name of the schedule.\nevery - An integer that represents the frequency of the schedule in number of units.\nunit - A string specifying the time unit for the schedule (e.g., seconds, minute, minutes, hour, hours).\nstartTime - (Optional) A UTC timestamp indicating when the schedule should start. All date times must be provided in GMT. If not specified the schedule will start when the schedule store reports ready.\nrun - A function that contains the code you want to execute on the defined schedule.\ncompletions - (Optional) An integer indicating the maximum number of times the schedule should run to completion. If not specified the schedule will run indefinitely.\nExamples Update a ConfigMap every 30 seconds:\nOnSchedule({ name: \"hello-interval\", every: 30, unit: \"seconds\", run: async () =\u003e { Log.info(\"Wait 30 seconds and create/update a ConfigMap\"); try { await K8s(kind.ConfigMap).Apply({ metadata: { name: \"last-updated\", namespace: \"default\", }, data: { count: `${new Date()}`, }, }); } catch (error) { Log.error(error, \"Failed to apply ConfigMap using server-side apply.\"); } }, }); Refresh an AWSToken every 24 hours, with a delayed start of 30 seconds, running a total of 3 times:\nOnSchedule({ name: \"refresh-aws-token\", every: 24, unit: \"hours\", startTime: new Date(new Date().getTime() + 1000 * 30), run: async () =\u003e { await RefreshAWSToken(); }, completions: 3, }); Advantages Simplifies scheduling recurring tasks without the need for complex CronJob configurations. Provides flexibility to define schedules in a human-readable format. Allows you to execute code with precision at specified intervals. Supports limiting the number of schedule completions for finite tasks. ","categories":"","description":"","excerpt":"The OnSchedule feature allows you to schedule and automate the …","ref":"/v0.20.0/onschedule/","tags":"","title":"OnSchedule"},{"body":"The OnSchedule feature allows you to schedule and automate the execution of specific code at predefined intervals or schedules. This feature is designed to simplify recurring tasks and can serve as an alternative to traditional CronJobs. This code is designed to be run at the top level on a Capability, not within a function like When.\nNote - To use this feature in dev mode you MUST set PEPR_WATCH_MODE=\"true\". This is because the scheduler only runs on the watch controller and the watch controller is not started by default in dev mode.\nFor example: PEPR_WATCH_MODE=\"true\" npx pepr dev\nBest Practices OnSchedule is designed for targeting intervals equal to or larger than 30 seconds due to the storage mechanism used to archive schedule info.\nUsage Create a recurring task execution by calling the OnSchedule function with the following parameters:\nname - The unique name of the schedule.\nevery - An integer that represents the frequency of the schedule in number of units.\nunit - A string specifying the time unit for the schedule (e.g., seconds, minute, minutes, hour, hours).\nstartTime - (Optional) A UTC timestamp indicating when the schedule should start. All date times must be provided in GMT. If not specified the schedule will start when the schedule store reports ready.\nrun - A function that contains the code you want to execute on the defined schedule.\ncompletions - (Optional) An integer indicating the maximum number of times the schedule should run to completion. If not specified the schedule will run indefinitely.\nExamples Update a ConfigMap every 30 seconds:\nOnSchedule({ name: \"hello-interval\", every: 30, unit: \"seconds\", run: async () =\u003e { Log.info(\"Wait 30 seconds and create/update a ConfigMap\"); try { await K8s(kind.ConfigMap).Apply({ metadata: { name: \"last-updated\", namespace: \"default\", }, data: { count: `${new Date()}`, }, }); } catch (error) { Log.error(error, \"Failed to apply ConfigMap using server-side apply.\"); } }, }); Refresh an AWSToken every 24 hours, with a delayed start of 30 seconds, running a total of 3 times:\nOnSchedule({ name: \"refresh-aws-token\", every: 24, unit: \"hours\", startTime: new Date(new Date().getTime() + 1000 * 30), run: async () =\u003e { await RefreshAWSToken(); }, completions: 3, }); Advantages Simplifies scheduling recurring tasks without the need for complex CronJob configurations. Provides flexibility to define schedules in a human-readable format. Allows you to execute code with precision at specified intervals. Supports limiting the number of schedule completions for finite tasks. ","categories":"","description":"","excerpt":"The OnSchedule feature allows you to schedule and automate the …","ref":"/v0.20.1/onschedule/","tags":"","title":"OnSchedule"},{"body":"The OnSchedule feature allows you to schedule and automate the execution of specific code at predefined intervals or schedules. This feature is designed to simplify recurring tasks and can serve as an alternative to traditional CronJobs. This code is designed to be run at the top level on a Capability, not within a function like When.\nNote - To use this feature in dev mode you MUST set PEPR_WATCH_MODE=\"true\". This is because the scheduler only runs on the watch controller and the watch controller is not started by default in dev mode.\nFor example: PEPR_WATCH_MODE=\"true\" npx pepr dev\nBest Practices OnSchedule is designed for targeting intervals equal to or larger than 30 seconds due to the storage mechanism used to archive schedule info.\nUsage Create a recurring task execution by calling the OnSchedule function with the following parameters:\nname - The unique name of the schedule.\nevery - An integer that represents the frequency of the schedule in number of units.\nunit - A string specifying the time unit for the schedule (e.g., seconds, minute, minutes, hour, hours).\nstartTime - (Optional) A UTC timestamp indicating when the schedule should start. All date times must be provided in GMT. If not specified the schedule will start when the schedule store reports ready.\nrun - A function that contains the code you want to execute on the defined schedule.\ncompletions - (Optional) An integer indicating the maximum number of times the schedule should run to completion. If not specified the schedule will run indefinitely.\nExamples Update a ConfigMap every 30 seconds:\nOnSchedule({ name: \"hello-interval\", every: 30, unit: \"seconds\", run: async () =\u003e { Log.info(\"Wait 30 seconds and create/update a ConfigMap\"); try { await K8s(kind.ConfigMap).Apply({ metadata: { name: \"last-updated\", namespace: \"default\", }, data: { count: `${new Date()}`, }, }); } catch (error) { Log.error(error, \"Failed to apply ConfigMap using server-side apply.\"); } }, }); Refresh an AWSToken every 24 hours, with a delayed start of 30 seconds, running a total of 3 times:\nOnSchedule({ name: \"refresh-aws-token\", every: 24, unit: \"hours\", startTime: new Date(new Date().getTime() + 1000 * 30), run: async () =\u003e { await RefreshAWSToken(); }, completions: 3, }); Advantages Simplifies scheduling recurring tasks without the need for complex CronJob configurations. Provides flexibility to define schedules in a human-readable format. Allows you to execute code with precision at specified intervals. Supports limiting the number of schedule completions for finite tasks. ","categories":"","description":"","excerpt":"The OnSchedule feature allows you to schedule and automate the …","ref":"/v0.20.2/onschedule/","tags":"","title":"OnSchedule"},{"body":"The OnSchedule feature allows you to schedule and automate the execution of specific code at predefined intervals or schedules. This feature is designed to simplify recurring tasks and can serve as an alternative to traditional CronJobs. This code is designed to be run at the top level on a Capability, not within a function like When.\nNote - To use this feature in dev mode you MUST set PEPR_WATCH_MODE=\"true\". This is because the scheduler only runs on the watch controller and the watch controller is not started by default in dev mode.\nFor example: PEPR_WATCH_MODE=\"true\" npx pepr dev\nBest Practices OnSchedule is designed for targeting intervals equal to or larger than 30 seconds due to the storage mechanism used to archive schedule info.\nUsage Create a recurring task execution by calling the OnSchedule function with the following parameters:\nname - The unique name of the schedule.\nevery - An integer that represents the frequency of the schedule in number of units.\nunit - A string specifying the time unit for the schedule (e.g., seconds, minute, minutes, hour, hours).\nstartTime - (Optional) A UTC timestamp indicating when the schedule should start. All date times must be provided in GMT. If not specified the schedule will start when the schedule store reports ready.\nrun - A function that contains the code you want to execute on the defined schedule.\ncompletions - (Optional) An integer indicating the maximum number of times the schedule should run to completion. If not specified the schedule will run indefinitely.\nExamples Update a ConfigMap every 30 seconds:\nOnSchedule({ name: \"hello-interval\", every: 30, unit: \"seconds\", run: async () =\u003e { Log.info(\"Wait 30 seconds and create/update a ConfigMap\"); try { await K8s(kind.ConfigMap).Apply({ metadata: { name: \"last-updated\", namespace: \"default\", }, data: { count: `${new Date()}`, }, }); } catch (error) { Log.error(error, \"Failed to apply ConfigMap using server-side apply.\"); } }, }); Refresh an AWSToken every 24 hours, with a delayed start of 30 seconds, running a total of 3 times:\nOnSchedule({ name: \"refresh-aws-token\", every: 24, unit: \"hours\", startTime: new Date(new Date().getTime() + 1000 * 30), run: async () =\u003e { await RefreshAWSToken(); }, completions: 3, }); Advantages Simplifies scheduling recurring tasks without the need for complex CronJob configurations. Provides flexibility to define schedules in a human-readable format. Allows you to execute code with precision at specified intervals. Supports limiting the number of schedule completions for finite tasks. ","categories":"","description":"","excerpt":"The OnSchedule feature allows you to schedule and automate the …","ref":"/v0.20.3/onschedule/","tags":"","title":"OnSchedule"},{"body":"The OnSchedule feature allows you to schedule and automate the execution of specific code at predefined intervals or schedules. This feature is designed to simplify recurring tasks and can serve as an alternative to traditional CronJobs. This code is designed to be run at the top level on a Capability, not within a function like When.\nNote - To use this feature in dev mode you MUST set PEPR_WATCH_MODE=\"true\". This is because the scheduler only runs on the watch controller and the watch controller is not started by default in dev mode.\nFor example: PEPR_WATCH_MODE=\"true\" npx pepr dev\nBest Practices OnSchedule is designed for targeting intervals equal to or larger than 30 seconds due to the storage mechanism used to archive schedule info.\nUsage Create a recurring task execution by calling the OnSchedule function with the following parameters:\nname - The unique name of the schedule.\nevery - An integer that represents the frequency of the schedule in number of units.\nunit - A string specifying the time unit for the schedule (e.g., seconds, minute, minutes, hour, hours).\nstartTime - (Optional) A UTC timestamp indicating when the schedule should start. All date times must be provided in GMT. If not specified the schedule will start when the schedule store reports ready.\nrun - A function that contains the code you want to execute on the defined schedule.\ncompletions - (Optional) An integer indicating the maximum number of times the schedule should run to completion. If not specified the schedule will run indefinitely.\nExamples Update a ConfigMap every 30 seconds:\nOnSchedule({ name: \"hello-interval\", every: 30, unit: \"seconds\", run: async () =\u003e { Log.info(\"Wait 30 seconds and create/update a ConfigMap\"); try { await K8s(kind.ConfigMap).Apply({ metadata: { name: \"last-updated\", namespace: \"default\", }, data: { count: `${new Date()}`, }, }); } catch (error) { Log.error(error, \"Failed to apply ConfigMap using server-side apply.\"); } }, }); Refresh an AWSToken every 24 hours, with a delayed start of 30 seconds, running a total of 3 times:\nOnSchedule({ name: \"refresh-aws-token\", every: 24, unit: \"hours\", startTime: new Date(new Date().getTime() + 1000 * 30), run: async () =\u003e { await RefreshAWSToken(); }, completions: 3, }); Advantages Simplifies scheduling recurring tasks without the need for complex CronJob configurations. Provides flexibility to define schedules in a human-readable format. Allows you to execute code with precision at specified intervals. Supports limiting the number of schedule completions for finite tasks. ","categories":"","description":"","excerpt":"The OnSchedule feature allows you to schedule and automate the …","ref":"/v0.21.0/onschedule/","tags":"","title":"OnSchedule"},{"body":"The OnSchedule feature allows you to schedule and automate the execution of specific code at predefined intervals or schedules. This feature is designed to simplify recurring tasks and can serve as an alternative to traditional CronJobs. This code is designed to be run at the top level on a Capability, not within a function like When.\nNote - To use this feature in dev mode you MUST set PEPR_WATCH_MODE=\"true\". This is because the scheduler only runs on the watch controller and the watch controller is not started by default in dev mode.\nFor example: PEPR_WATCH_MODE=\"true\" npx pepr dev\nBest Practices OnSchedule is designed for targeting intervals equal to or larger than 30 seconds due to the storage mechanism used to archive schedule info.\nUsage Create a recurring task execution by calling the OnSchedule function with the following parameters:\nname - The unique name of the schedule.\nevery - An integer that represents the frequency of the schedule in number of units.\nunit - A string specifying the time unit for the schedule (e.g., seconds, minute, minutes, hour, hours).\nstartTime - (Optional) A UTC timestamp indicating when the schedule should start. All date times must be provided in GMT. If not specified the schedule will start when the schedule store reports ready.\nrun - A function that contains the code you want to execute on the defined schedule.\ncompletions - (Optional) An integer indicating the maximum number of times the schedule should run to completion. If not specified the schedule will run indefinitely.\nExamples Update a ConfigMap every 30 seconds:\nOnSchedule({ name: \"hello-interval\", every: 30, unit: \"seconds\", run: async () =\u003e { Log.info(\"Wait 30 seconds and create/update a ConfigMap\"); try { await K8s(kind.ConfigMap).Apply({ metadata: { name: \"last-updated\", namespace: \"default\", }, data: { count: `${new Date()}`, }, }); } catch (error) { Log.error(error, \"Failed to apply ConfigMap using server-side apply.\"); } }, }); Refresh an AWSToken every 24 hours, with a delayed start of 30 seconds, running a total of 3 times:\nOnSchedule({ name: \"refresh-aws-token\", every: 24, unit: \"hours\", startTime: new Date(new Date().getTime() + 1000 * 30), run: async () =\u003e { await RefreshAWSToken(); }, completions: 3, }); Advantages Simplifies scheduling recurring tasks without the need for complex CronJob configurations. Provides flexibility to define schedules in a human-readable format. Allows you to execute code with precision at specified intervals. Supports limiting the number of schedule completions for finite tasks. ","categories":"","description":"","excerpt":"The OnSchedule feature allows you to schedule and automate the …","ref":"/v0.21.1/onschedule/","tags":"","title":"OnSchedule"},{"body":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-post-init - Skip npm install, git init and VSCode launch pepr update Update the current Pepr Module to the latest SDK version and update the global Pepr CLI to the same version.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-template-update - Skip updating the template files pepr dev Connect a local cluster to a local version of the Pepr Controller to do real-time debugging of your module. Note the pepr dev assumes a K3d cluster is running by default. If you are working with Kind or another docker-based K8s distro, you will need to pass the --host host.docker.internal option to pepr dev. If working with a remote cluster you will have to give Pepr a host path to your machine that is reachable from the K8s cluster.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --host [host] - Host to listen on (default: “host.k3d.internal”) --confirm - Skip confirmation prompt pepr deploy Deploy the current module into a Kubernetes cluster, useful for CI systems. Not recommended for production use.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -i, --image [image] - Override the image tag --confirm - Skip confirmation prompt pepr monitor Monitor Validations for a given Pepr Module.\nUsage:\nnpx pepr monitor [options] \u003cmodule-uuid\u003e Options:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --help - Display help for command pepr build Create a zarf.yaml and K8s manifest for the current module. This includes everything needed to deploy Pepr and the current module into production environments.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -e, --entry-point [file] - Specify the entry point file to build with. (default: “pepr.ts”) -n, --no-embed - Disables embedding of deployment files into output module. Useful when creating library modules intended solely for reuse/distribution via NPM -r, --registry-info [\u003cregistry\u003e/\u003cusername\u003e] - Registry Info: Image registry and username. Note: You must be signed into the registry -o, --output-dir [output directory] - Define where to place build output --rbac-mode [admin|scoped] - Rbac Mode: admin, scoped (default: admin) (choices: “admin”, “scoped”, default: “admin”) ","categories":"","description":"","excerpt":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level …","ref":"/main/cli/","tags":"","title":"Pepr CLI"},{"body":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-post-init - Skip npm install, git init and VSCode launch pepr update Update the current Pepr Module to the latest SDK version and update the global Pepr CLI to the same version.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-template-update - Skip updating the template files pepr dev Connect a local cluster to a local version of the Pepr Controller to do real-time debugging of your module. Note the pepr dev assumes a K3d cluster is running by default. If you are working with Kind or another docker-based K8s distro, you will need to pass the --host host.docker.internal option to pepr dev. If working with a remote cluster you will have to give Pepr a host path to your machine that is reachable from the K8s cluster.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --host [host] - Host to listen on (default: “host.k3d.internal”) --confirm - Skip confirmation prompt pepr deploy Deploy the current module into a Kubernetes cluster, useful for CI systems. Not recommended for production use.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -i, --image [image] - Override the image tag --confirm - Skip confirmation prompt pepr monitor Monitor Validations for a given Pepr Module.\nUsage:\nnpx pepr monitor [options] \u003cmodule-uuid\u003e Options:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --help - Display help for command pepr build Create a zarf.yaml and K8s manifest for the current module. This includes everything needed to deploy Pepr and the current module into production environments.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -e, --entry-point [file] - Specify the entry point file to build with. (default: “pepr.ts”) -n, --no-embed - Disables embedding of deployment files into output module. Useful when creating library modules intended solely for reuse/distribution via NPM -r, --registry-info [\u003cregistry\u003e/\u003cusername\u003e] - Registry Info: Image registry and username. Note: You must be signed into the registry -o, --output-dir [output directory] - Define where to place build output --rbac-mode [admin|scoped] - Rbac Mode: admin, scoped (default: admin) (choices: “admin”, “scoped”, default: “admin”) ","categories":"","description":"","excerpt":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level …","ref":"/v0.19.0/cli/","tags":"","title":"Pepr CLI"},{"body":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-post-init - Skip npm install, git init and VSCode launch pepr update Update the current Pepr Module to the latest SDK version and update the global Pepr CLI to the same version.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-template-update - Skip updating the template files pepr dev Connect a local cluster to a local version of the Pepr Controller to do real-time debugging of your module. Note the pepr dev assumes a K3d cluster is running by default. If you are working with Kind or another docker-based K8s distro, you will need to pass the --host host.docker.internal option to pepr dev. If working with a remote cluster you will have to give Pepr a host path to your machine that is reachable from the K8s cluster.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --host [host] - Host to listen on (default: “host.k3d.internal”) --confirm - Skip confirmation prompt pepr deploy Deploy the current module into a Kubernetes cluster, useful for CI systems. Not recommended for production use.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -i, --image [image] - Override the image tag --confirm - Skip confirmation prompt pepr monitor Monitor Validations for a given Pepr Module.\nUsage:\nnpx pepr monitor [options] \u003cmodule-uuid\u003e Options:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --help - Display help for command pepr build Create a zarf.yaml and K8s manifest for the current module. This includes everything needed to deploy Pepr and the current module into production environments.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -e, --entry-point [file] - Specify the entry point file to build with. (default: “pepr.ts”) -n, --no-embed - Disables embedding of deployment files into output module. Useful when creating library modules intended solely for reuse/distribution via NPM -r, --registry-info [\u003cregistry\u003e/\u003cusername\u003e] - Registry Info: Image registry and username. Note: You must be signed into the registry -o, --output-dir [output directory] - Define where to place build output --rbac-mode [admin|scoped] - Rbac Mode: admin, scoped (default: admin) (choices: “admin”, “scoped”, default: “admin”) ","categories":"","description":"","excerpt":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level …","ref":"/v0.20.0/cli/","tags":"","title":"Pepr CLI"},{"body":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-post-init - Skip npm install, git init and VSCode launch pepr update Update the current Pepr Module to the latest SDK version and update the global Pepr CLI to the same version.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-template-update - Skip updating the template files pepr dev Connect a local cluster to a local version of the Pepr Controller to do real-time debugging of your module. Note the pepr dev assumes a K3d cluster is running by default. If you are working with Kind or another docker-based K8s distro, you will need to pass the --host host.docker.internal option to pepr dev. If working with a remote cluster you will have to give Pepr a host path to your machine that is reachable from the K8s cluster.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --host [host] - Host to listen on (default: “host.k3d.internal”) --confirm - Skip confirmation prompt pepr deploy Deploy the current module into a Kubernetes cluster, useful for CI systems. Not recommended for production use.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -i, --image [image] - Override the image tag --confirm - Skip confirmation prompt pepr monitor Monitor Validations for a given Pepr Module.\nUsage:\nnpx pepr monitor [options] \u003cmodule-uuid\u003e Options:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --help - Display help for command pepr build Create a zarf.yaml and K8s manifest for the current module. This includes everything needed to deploy Pepr and the current module into production environments.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -e, --entry-point [file] - Specify the entry point file to build with. (default: “pepr.ts”) -n, --no-embed - Disables embedding of deployment files into output module. Useful when creating library modules intended solely for reuse/distribution via NPM -r, --registry-info [\u003cregistry\u003e/\u003cusername\u003e] - Registry Info: Image registry and username. Note: You must be signed into the registry -o, --output-dir [output directory] - Define where to place build output --rbac-mode [admin|scoped] - Rbac Mode: admin, scoped (default: admin) (choices: “admin”, “scoped”, default: “admin”) ","categories":"","description":"","excerpt":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level …","ref":"/v0.20.1/cli/","tags":"","title":"Pepr CLI"},{"body":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-post-init - Skip npm install, git init and VSCode launch pepr update Update the current Pepr Module to the latest SDK version and update the global Pepr CLI to the same version.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-template-update - Skip updating the template files pepr dev Connect a local cluster to a local version of the Pepr Controller to do real-time debugging of your module. Note the pepr dev assumes a K3d cluster is running by default. If you are working with Kind or another docker-based K8s distro, you will need to pass the --host host.docker.internal option to pepr dev. If working with a remote cluster you will have to give Pepr a host path to your machine that is reachable from the K8s cluster.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --host [host] - Host to listen on (default: “host.k3d.internal”) --confirm - Skip confirmation prompt pepr deploy Deploy the current module into a Kubernetes cluster, useful for CI systems. Not recommended for production use.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -i, --image [image] - Override the image tag --confirm - Skip confirmation prompt pepr monitor Monitor Validations for a given Pepr Module.\nUsage:\nnpx pepr monitor [options] \u003cmodule-uuid\u003e Options:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --help - Display help for command pepr build Create a zarf.yaml and K8s manifest for the current module. This includes everything needed to deploy Pepr and the current module into production environments.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -e, --entry-point [file] - Specify the entry point file to build with. (default: “pepr.ts”) -n, --no-embed - Disables embedding of deployment files into output module. Useful when creating library modules intended solely for reuse/distribution via NPM -r, --registry-info [\u003cregistry\u003e/\u003cusername\u003e] - Registry Info: Image registry and username. Note: You must be signed into the registry -o, --output-dir [output directory] - Define where to place build output --rbac-mode [admin|scoped] - Rbac Mode: admin, scoped (default: admin) (choices: “admin”, “scoped”, default: “admin”) ","categories":"","description":"","excerpt":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level …","ref":"/v0.20.2/cli/","tags":"","title":"Pepr CLI"},{"body":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-post-init - Skip npm install, git init and VSCode launch pepr update Update the current Pepr Module to the latest SDK version and update the global Pepr CLI to the same version.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-template-update - Skip updating the template files pepr dev Connect a local cluster to a local version of the Pepr Controller to do real-time debugging of your module. Note the pepr dev assumes a K3d cluster is running by default. If you are working with Kind or another docker-based K8s distro, you will need to pass the --host host.docker.internal option to pepr dev. If working with a remote cluster you will have to give Pepr a host path to your machine that is reachable from the K8s cluster.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --host [host] - Host to listen on (default: “host.k3d.internal”) --confirm - Skip confirmation prompt pepr deploy Deploy the current module into a Kubernetes cluster, useful for CI systems. Not recommended for production use.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -i, --image [image] - Override the image tag --confirm - Skip confirmation prompt pepr monitor Monitor Validations for a given Pepr Module.\nUsage:\nnpx pepr monitor [options] \u003cmodule-uuid\u003e Options:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --help - Display help for command pepr build Create a zarf.yaml and K8s manifest for the current module. This includes everything needed to deploy Pepr and the current module into production environments.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -e, --entry-point [file] - Specify the entry point file to build with. (default: “pepr.ts”) -n, --no-embed - Disables embedding of deployment files into output module. Useful when creating library modules intended solely for reuse/distribution via NPM -r, --registry-info [\u003cregistry\u003e/\u003cusername\u003e] - Registry Info: Image registry and username. Note: You must be signed into the registry -o, --output-dir [output directory] - Define where to place build output --rbac-mode [admin|scoped] - Rbac Mode: admin, scoped (default: admin) (choices: “admin”, “scoped”, default: “admin”) ","categories":"","description":"","excerpt":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level …","ref":"/v0.20.3/cli/","tags":"","title":"Pepr CLI"},{"body":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-post-init - Skip npm install, git init and VSCode launch pepr update Update the current Pepr Module to the latest SDK version and update the global Pepr CLI to the same version.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-template-update - Skip updating the template files pepr dev Connect a local cluster to a local version of the Pepr Controller to do real-time debugging of your module. Note the pepr dev assumes a K3d cluster is running by default. If you are working with Kind or another docker-based K8s distro, you will need to pass the --host host.docker.internal option to pepr dev. If working with a remote cluster you will have to give Pepr a host path to your machine that is reachable from the K8s cluster.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --host [host] - Host to listen on (default: “host.k3d.internal”) --confirm - Skip confirmation prompt pepr deploy Deploy the current module into a Kubernetes cluster, useful for CI systems. Not recommended for production use.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -i, --image [image] - Override the image tag --confirm - Skip confirmation prompt pepr monitor Monitor Validations for a given Pepr Module.\nUsage:\nnpx pepr monitor [options] \u003cmodule-uuid\u003e Options:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --help - Display help for command pepr build Create a zarf.yaml and K8s manifest for the current module. This includes everything needed to deploy Pepr and the current module into production environments.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -e, --entry-point [file] - Specify the entry point file to build with. (default: “pepr.ts”) -n, --no-embed - Disables embedding of deployment files into output module. Useful when creating library modules intended solely for reuse/distribution via NPM -r, --registry-info [\u003cregistry\u003e/\u003cusername\u003e] - Registry Info: Image registry and username. Note: You must be signed into the registry -o, --output-dir [output directory] - Define where to place build output --rbac-mode [admin|scoped] - Rbac Mode: admin, scoped (default: admin) (choices: “admin”, “scoped”, default: “admin”) ","categories":"","description":"","excerpt":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level …","ref":"/v0.21.0/cli/","tags":"","title":"Pepr CLI"},{"body":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-post-init - Skip npm install, git init and VSCode launch pepr update Update the current Pepr Module to the latest SDK version and update the global Pepr CLI to the same version.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) --skip-template-update - Skip updating the template files pepr dev Connect a local cluster to a local version of the Pepr Controller to do real-time debugging of your module. Note the pepr dev assumes a K3d cluster is running by default. If you are working with Kind or another docker-based K8s distro, you will need to pass the --host host.docker.internal option to pepr dev. If working with a remote cluster you will have to give Pepr a host path to your machine that is reachable from the K8s cluster.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --host [host] - Host to listen on (default: “host.k3d.internal”) --confirm - Skip confirmation prompt pepr deploy Deploy the current module into a Kubernetes cluster, useful for CI systems. Not recommended for production use.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -i, --image [image] - Override the image tag --confirm - Skip confirmation prompt pepr monitor Monitor Validations for a given Pepr Module.\nUsage:\nnpx pepr monitor [options] \u003cmodule-uuid\u003e Options:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -h, --help - Display help for command pepr build Create a zarf.yaml and K8s manifest for the current module. This includes everything needed to deploy Pepr and the current module into production environments.\nOptions:\n-l, --log-level [level] - Log level: debug, info, warn, error (default: “info”) -e, --entry-point [file] - Specify the entry point file to build with. (default: “pepr.ts”) -n, --no-embed - Disables embedding of deployment files into output module. Useful when creating library modules intended solely for reuse/distribution via NPM -r, --registry-info [\u003cregistry\u003e/\u003cusername\u003e] - Registry Info: Image registry and username. Note: You must be signed into the registry -o, --output-dir [output directory] - Define where to place build output --rbac-mode [admin|scoped] - Rbac Mode: admin, scoped (default: admin) (choices: “admin”, “scoped”, default: “admin”) ","categories":"","description":"","excerpt":"pepr init Initialize a new Pepr Module.\nOptions:\n-l, --log-level …","ref":"/v0.21.1/cli/","tags":"","title":"Pepr CLI"},{"body":"Each Pepr Module is it’s own Typescript project, produced by pepr init. Typically a module is maintained by a unique group or system. For example, a module for internal Zarf mutations would be different from a module for Big Bang. An important idea with modules is that they are wholly independent of one another. This means that 2 different modules can be on completely different versions of Pepr and any other dependencies; their only interaction is through the standard K8s interfaces like any other webhook or controller.\nModule development lifecycle Create the module:\nUse pepr init to generate a new module.\nQuickly validate system setup:\nEvery new module includes a sample Pepr Capability called HelloPepr. By default, this capability is deployed and monitoring the pepr-demo namespace. There is a sample yaml also included you can use to see Pepr in your cluster. Here’s the quick steps to do that after pepr init:\n# cd to the newly-created Pepr module folder cd my-module-name # If you don't already have a local K8s cluster, you can set one up with k3d npm run k3d-setup # Launch pepr dev mode # If using another local K8s distro instead of k3d, use `pepr dev --host host.docker.internal` pepr dev # From another terminal, apply the sample yaml kubectl apply -f capabilities/hello-pepr.samples.yaml # Verify the configmaps were transformed using kubectl, k9s or another tool Create your custom Pepr Capabilities\nNow that you have confirmed Pepr is working, you can now create new capabilities. You’ll also want to disable the HelloPepr capability in your module (pepr.ts) before pushing to production. You can disable by commenting out or deleting the HelloPepr variable below:\nnew PeprModule(cfg, [ // Remove or comment the line below to disable the HelloPepr capability HelloPepr, // Your additional capabilities go here ]); Note: if you also delete the capabilities/hello-pepr.ts file, it will be added again on the next pepr update so you have the latest examples usages from the Pepr SDK. Therefore, it is sufficient to remove the entry from your pepr.ts module config.\nBuild and deploy the Pepr Module\nMost of the time, you’ll likely be iterating on a module with pepr dev for real-time feedback and validation Once you are ready to move beyond the local dev environment, Pepr provides deployment and build tools you can use.\npepr deploy - you can use this command to build your module and deploy it into any K8s cluster your current kubecontext has access to. This setup is ideal for CI systems during testing, but is not recommended for production use. See pepr deploy for more info.\nAdvanced Module Configuration By default, when you run pepr init, the module is not configured with any additional options. Currently, there are 3 options you can configure:\ndeferStart - if set to true, the module will not start automatically. You will need to call start() manually. This is useful if you want to do some additional setup before the module controller starts. You can also use this to change the default port that the controller listens on.\nbeforeHook - an optional callback that will be called before every request is processed. This is useful if you want to do some additional logging or validation before the request is processed.\nafterHook - an optional callback that will be called after every request is processed. This is useful if you want to do some additional logging or validation after the request is processed.\nYou can configure each of these by modifying the pepr.ts file in your module. Here’s an example of how you would configure each of these options:\nconst module = new PeprModule( cfg, [ // Your capabilities go here ], { deferStart: true, beforeHook: req =\u003e { // Any actions you want to perform before the request is processed, including modifying the request. }, afterHook: res =\u003e { // Any actions you want to perform after the request is processed, including modifying the response. }, } ); // Do any additional setup before starting the controller module.start(); ","categories":"","description":"","excerpt":"Each Pepr Module is it’s own Typescript project, produced by pepr …","ref":"/main/module/","tags":"","title":"Pepr Module"},{"body":"Each Pepr Module is it’s own Typescript project, produced by pepr init. Typically a module is maintained by a unique group or system. For example, a module for internal Zarf mutations would be different from a module for Big Bang. An important idea with modules is that they are wholly independent of one another. This means that 2 different modules can be on completely different versions of Pepr and any other dependencies; their only interaction is through the standard K8s interfaces like any other webhook or controller.\nModule development lifecycle Create the module:\nUse pepr init to generate a new module.\nQuickly validate system setup:\nEvery new module includes a sample Pepr Capability called HelloPepr. By default, this capability is deployed and monitoring the pepr-demo namespace. There is a sample yaml also included you can use to see Pepr in your cluster. Here’s the quick steps to do that after pepr init:\n# cd to the newly-created Pepr module folder cd my-module-name # If you don't already have a local K8s cluster, you can set one up with k3d npm run k3d-setup # Launch pepr dev mode # If using another local K8s distro instead of k3d, use `pepr dev --host host.docker.internal` pepr dev # From another terminal, apply the sample yaml kubectl apply -f capabilities/hello-pepr.samples.yaml # Verify the configmaps were transformed using kubectl, k9s or another tool Create your custom Pepr Capabilities\nNow that you have confirmed Pepr is working, you can now create new capabilities. You’ll also want to disable the HelloPepr capability in your module (pepr.ts) before pushing to production. You can disable by commenting out or deleting the HelloPepr variable below:\nnew PeprModule(cfg, [ // Remove or comment the line below to disable the HelloPepr capability HelloPepr, // Your additional capabilities go here ]); Note: if you also delete the capabilities/hello-pepr.ts file, it will be added again on the next pepr update so you have the latest examples usages from the Pepr SDK. Therefore, it is sufficient to remove the entry from your pepr.ts module config.\nBuild and deploy the Pepr Module\nMost of the time, you’ll likely be iterating on a module with pepr dev for real-time feedback and validation Once you are ready to move beyond the local dev environment, Pepr provides deployment and build tools you can use.\npepr deploy - you can use this command to build your module and deploy it into any K8s cluster your current kubecontext has access to. This setup is ideal for CI systems during testing, but is not recommended for production use. See pepr deploy for more info.\nAdvanced Module Configuration By default, when you run pepr init, the module is not configured with any additional options. Currently, there are 3 options you can configure:\ndeferStart - if set to true, the module will not start automatically. You will need to call start() manually. This is useful if you want to do some additional setup before the module controller starts. You can also use this to change the default port that the controller listens on.\nbeforeHook - an optional callback that will be called before every request is processed. This is useful if you want to do some additional logging or validation before the request is processed.\nafterHook - an optional callback that will be called after every request is processed. This is useful if you want to do some additional logging or validation after the request is processed.\nYou can configure each of these by modifying the pepr.ts file in your module. Here’s an example of how you would configure each of these options:\nconst module = new PeprModule( cfg, [ // Your capabilities go here ], { deferStart: true, beforeHook: req =\u003e { // Any actions you want to perform before the request is processed, including modifying the request. }, afterHook: res =\u003e { // Any actions you want to perform after the request is processed, including modifying the response. }, } ); // Do any additional setup before starting the controller module.start(); ","categories":"","description":"","excerpt":"Each Pepr Module is it’s own Typescript project, produced by pepr …","ref":"/v0.19.0/module/","tags":"","title":"Pepr Module"},{"body":"Each Pepr Module is it’s own Typescript project, produced by pepr init. Typically a module is maintained by a unique group or system. For example, a module for internal Zarf mutations would be different from a module for Big Bang. An important idea with modules is that they are wholly independent of one another. This means that 2 different modules can be on completely different versions of Pepr and any other dependencies; their only interaction is through the standard K8s interfaces like any other webhook or controller.\nModule development lifecycle Create the module:\nUse pepr init to generate a new module.\nQuickly validate system setup:\nEvery new module includes a sample Pepr Capability called HelloPepr. By default, this capability is deployed and monitoring the pepr-demo namespace. There is a sample yaml also included you can use to see Pepr in your cluster. Here’s the quick steps to do that after pepr init:\n# cd to the newly-created Pepr module folder cd my-module-name # If you don't already have a local K8s cluster, you can set one up with k3d npm run k3d-setup # Launch pepr dev mode # If using another local K8s distro instead of k3d, use `pepr dev --host host.docker.internal` pepr dev # From another terminal, apply the sample yaml kubectl apply -f capabilities/hello-pepr.samples.yaml # Verify the configmaps were transformed using kubectl, k9s or another tool Create your custom Pepr Capabilities\nNow that you have confirmed Pepr is working, you can now create new capabilities. You’ll also want to disable the HelloPepr capability in your module (pepr.ts) before pushing to production. You can disable by commenting out or deleting the HelloPepr variable below:\nnew PeprModule(cfg, [ // Remove or comment the line below to disable the HelloPepr capability HelloPepr, // Your additional capabilities go here ]); Note: if you also delete the capabilities/hello-pepr.ts file, it will be added again on the next pepr update so you have the latest examples usages from the Pepr SDK. Therefore, it is sufficient to remove the entry from your pepr.ts module config.\nBuild and deploy the Pepr Module\nMost of the time, you’ll likely be iterating on a module with pepr dev for real-time feedback and validation Once you are ready to move beyond the local dev environment, Pepr provides deployment and build tools you can use.\npepr deploy - you can use this command to build your module and deploy it into any K8s cluster your current kubecontext has access to. This setup is ideal for CI systems during testing, but is not recommended for production use. See pepr deploy for more info.\nAdvanced Module Configuration By default, when you run pepr init, the module is not configured with any additional options. Currently, there are 3 options you can configure:\ndeferStart - if set to true, the module will not start automatically. You will need to call start() manually. This is useful if you want to do some additional setup before the module controller starts. You can also use this to change the default port that the controller listens on.\nbeforeHook - an optional callback that will be called before every request is processed. This is useful if you want to do some additional logging or validation before the request is processed.\nafterHook - an optional callback that will be called after every request is processed. This is useful if you want to do some additional logging or validation after the request is processed.\nYou can configure each of these by modifying the pepr.ts file in your module. Here’s an example of how you would configure each of these options:\nconst module = new PeprModule( cfg, [ // Your capabilities go here ], { deferStart: true, beforeHook: req =\u003e { // Any actions you want to perform before the request is processed, including modifying the request. }, afterHook: res =\u003e { // Any actions you want to perform after the request is processed, including modifying the response. }, } ); // Do any additional setup before starting the controller module.start(); ","categories":"","description":"","excerpt":"Each Pepr Module is it’s own Typescript project, produced by pepr …","ref":"/v0.20.0/module/","tags":"","title":"Pepr Module"},{"body":"Each Pepr Module is it’s own Typescript project, produced by pepr init. Typically a module is maintained by a unique group or system. For example, a module for internal Zarf mutations would be different from a module for Big Bang. An important idea with modules is that they are wholly independent of one another. This means that 2 different modules can be on completely different versions of Pepr and any other dependencies; their only interaction is through the standard K8s interfaces like any other webhook or controller.\nModule development lifecycle Create the module:\nUse pepr init to generate a new module.\nQuickly validate system setup:\nEvery new module includes a sample Pepr Capability called HelloPepr. By default, this capability is deployed and monitoring the pepr-demo namespace. There is a sample yaml also included you can use to see Pepr in your cluster. Here’s the quick steps to do that after pepr init:\n# cd to the newly-created Pepr module folder cd my-module-name # If you don't already have a local K8s cluster, you can set one up with k3d npm run k3d-setup # Launch pepr dev mode # If using another local K8s distro instead of k3d, use `pepr dev --host host.docker.internal` pepr dev # From another terminal, apply the sample yaml kubectl apply -f capabilities/hello-pepr.samples.yaml # Verify the configmaps were transformed using kubectl, k9s or another tool Create your custom Pepr Capabilities\nNow that you have confirmed Pepr is working, you can now create new capabilities. You’ll also want to disable the HelloPepr capability in your module (pepr.ts) before pushing to production. You can disable by commenting out or deleting the HelloPepr variable below:\nnew PeprModule(cfg, [ // Remove or comment the line below to disable the HelloPepr capability HelloPepr, // Your additional capabilities go here ]); Note: if you also delete the capabilities/hello-pepr.ts file, it will be added again on the next pepr update so you have the latest examples usages from the Pepr SDK. Therefore, it is sufficient to remove the entry from your pepr.ts module config.\nBuild and deploy the Pepr Module\nMost of the time, you’ll likely be iterating on a module with pepr dev for real-time feedback and validation Once you are ready to move beyond the local dev environment, Pepr provides deployment and build tools you can use.\npepr deploy - you can use this command to build your module and deploy it into any K8s cluster your current kubecontext has access to. This setup is ideal for CI systems during testing, but is not recommended for production use. See pepr deploy for more info.\nAdvanced Module Configuration By default, when you run pepr init, the module is not configured with any additional options. Currently, there are 3 options you can configure:\ndeferStart - if set to true, the module will not start automatically. You will need to call start() manually. This is useful if you want to do some additional setup before the module controller starts. You can also use this to change the default port that the controller listens on.\nbeforeHook - an optional callback that will be called before every request is processed. This is useful if you want to do some additional logging or validation before the request is processed.\nafterHook - an optional callback that will be called after every request is processed. This is useful if you want to do some additional logging or validation after the request is processed.\nYou can configure each of these by modifying the pepr.ts file in your module. Here’s an example of how you would configure each of these options:\nconst module = new PeprModule( cfg, [ // Your capabilities go here ], { deferStart: true, beforeHook: req =\u003e { // Any actions you want to perform before the request is processed, including modifying the request. }, afterHook: res =\u003e { // Any actions you want to perform after the request is processed, including modifying the response. }, } ); // Do any additional setup before starting the controller module.start(); ","categories":"","description":"","excerpt":"Each Pepr Module is it’s own Typescript project, produced by pepr …","ref":"/v0.20.1/module/","tags":"","title":"Pepr Module"},{"body":"Each Pepr Module is it’s own Typescript project, produced by pepr init. Typically a module is maintained by a unique group or system. For example, a module for internal Zarf mutations would be different from a module for Big Bang. An important idea with modules is that they are wholly independent of one another. This means that 2 different modules can be on completely different versions of Pepr and any other dependencies; their only interaction is through the standard K8s interfaces like any other webhook or controller.\nModule development lifecycle Create the module:\nUse pepr init to generate a new module.\nQuickly validate system setup:\nEvery new module includes a sample Pepr Capability called HelloPepr. By default, this capability is deployed and monitoring the pepr-demo namespace. There is a sample yaml also included you can use to see Pepr in your cluster. Here’s the quick steps to do that after pepr init:\n# cd to the newly-created Pepr module folder cd my-module-name # If you don't already have a local K8s cluster, you can set one up with k3d npm run k3d-setup # Launch pepr dev mode # If using another local K8s distro instead of k3d, use `pepr dev --host host.docker.internal` pepr dev # From another terminal, apply the sample yaml kubectl apply -f capabilities/hello-pepr.samples.yaml # Verify the configmaps were transformed using kubectl, k9s or another tool Create your custom Pepr Capabilities\nNow that you have confirmed Pepr is working, you can now create new capabilities. You’ll also want to disable the HelloPepr capability in your module (pepr.ts) before pushing to production. You can disable by commenting out or deleting the HelloPepr variable below:\nnew PeprModule(cfg, [ // Remove or comment the line below to disable the HelloPepr capability HelloPepr, // Your additional capabilities go here ]); Note: if you also delete the capabilities/hello-pepr.ts file, it will be added again on the next pepr update so you have the latest examples usages from the Pepr SDK. Therefore, it is sufficient to remove the entry from your pepr.ts module config.\nBuild and deploy the Pepr Module\nMost of the time, you’ll likely be iterating on a module with pepr dev for real-time feedback and validation Once you are ready to move beyond the local dev environment, Pepr provides deployment and build tools you can use.\npepr deploy - you can use this command to build your module and deploy it into any K8s cluster your current kubecontext has access to. This setup is ideal for CI systems during testing, but is not recommended for production use. See pepr deploy for more info.\nAdvanced Module Configuration By default, when you run pepr init, the module is not configured with any additional options. Currently, there are 3 options you can configure:\ndeferStart - if set to true, the module will not start automatically. You will need to call start() manually. This is useful if you want to do some additional setup before the module controller starts. You can also use this to change the default port that the controller listens on.\nbeforeHook - an optional callback that will be called before every request is processed. This is useful if you want to do some additional logging or validation before the request is processed.\nafterHook - an optional callback that will be called after every request is processed. This is useful if you want to do some additional logging or validation after the request is processed.\nYou can configure each of these by modifying the pepr.ts file in your module. Here’s an example of how you would configure each of these options:\nconst module = new PeprModule( cfg, [ // Your capabilities go here ], { deferStart: true, beforeHook: req =\u003e { // Any actions you want to perform before the request is processed, including modifying the request. }, afterHook: res =\u003e { // Any actions you want to perform after the request is processed, including modifying the response. }, } ); // Do any additional setup before starting the controller module.start(); ","categories":"","description":"","excerpt":"Each Pepr Module is it’s own Typescript project, produced by pepr …","ref":"/v0.20.2/module/","tags":"","title":"Pepr Module"},{"body":"Each Pepr Module is it’s own Typescript project, produced by pepr init. Typically a module is maintained by a unique group or system. For example, a module for internal Zarf mutations would be different from a module for Big Bang. An important idea with modules is that they are wholly independent of one another. This means that 2 different modules can be on completely different versions of Pepr and any other dependencies; their only interaction is through the standard K8s interfaces like any other webhook or controller.\nModule development lifecycle Create the module:\nUse pepr init to generate a new module.\nQuickly validate system setup:\nEvery new module includes a sample Pepr Capability called HelloPepr. By default, this capability is deployed and monitoring the pepr-demo namespace. There is a sample yaml also included you can use to see Pepr in your cluster. Here’s the quick steps to do that after pepr init:\n# cd to the newly-created Pepr module folder cd my-module-name # If you don't already have a local K8s cluster, you can set one up with k3d npm run k3d-setup # Launch pepr dev mode # If using another local K8s distro instead of k3d, use `pepr dev --host host.docker.internal` pepr dev # From another terminal, apply the sample yaml kubectl apply -f capabilities/hello-pepr.samples.yaml # Verify the configmaps were transformed using kubectl, k9s or another tool Create your custom Pepr Capabilities\nNow that you have confirmed Pepr is working, you can now create new capabilities. You’ll also want to disable the HelloPepr capability in your module (pepr.ts) before pushing to production. You can disable by commenting out or deleting the HelloPepr variable below:\nnew PeprModule(cfg, [ // Remove or comment the line below to disable the HelloPepr capability HelloPepr, // Your additional capabilities go here ]); Note: if you also delete the capabilities/hello-pepr.ts file, it will be added again on the next pepr update so you have the latest examples usages from the Pepr SDK. Therefore, it is sufficient to remove the entry from your pepr.ts module config.\nBuild and deploy the Pepr Module\nMost of the time, you’ll likely be iterating on a module with pepr dev for real-time feedback and validation Once you are ready to move beyond the local dev environment, Pepr provides deployment and build tools you can use.\npepr deploy - you can use this command to build your module and deploy it into any K8s cluster your current kubecontext has access to. This setup is ideal for CI systems during testing, but is not recommended for production use. See pepr deploy for more info.\nAdvanced Module Configuration By default, when you run pepr init, the module is not configured with any additional options. Currently, there are 3 options you can configure:\ndeferStart - if set to true, the module will not start automatically. You will need to call start() manually. This is useful if you want to do some additional setup before the module controller starts. You can also use this to change the default port that the controller listens on.\nbeforeHook - an optional callback that will be called before every request is processed. This is useful if you want to do some additional logging or validation before the request is processed.\nafterHook - an optional callback that will be called after every request is processed. This is useful if you want to do some additional logging or validation after the request is processed.\nYou can configure each of these by modifying the pepr.ts file in your module. Here’s an example of how you would configure each of these options:\nconst module = new PeprModule( cfg, [ // Your capabilities go here ], { deferStart: true, beforeHook: req =\u003e { // Any actions you want to perform before the request is processed, including modifying the request. }, afterHook: res =\u003e { // Any actions you want to perform after the request is processed, including modifying the response. }, } ); // Do any additional setup before starting the controller module.start(); ","categories":"","description":"","excerpt":"Each Pepr Module is it’s own Typescript project, produced by pepr …","ref":"/v0.20.3/module/","tags":"","title":"Pepr Module"},{"body":"Each Pepr Module is it’s own Typescript project, produced by pepr init. Typically a module is maintained by a unique group or system. For example, a module for internal Zarf mutations would be different from a module for Big Bang. An important idea with modules is that they are wholly independent of one another. This means that 2 different modules can be on completely different versions of Pepr and any other dependencies; their only interaction is through the standard K8s interfaces like any other webhook or controller.\nModule development lifecycle Create the module:\nUse pepr init to generate a new module.\nQuickly validate system setup:\nEvery new module includes a sample Pepr Capability called HelloPepr. By default, this capability is deployed and monitoring the pepr-demo namespace. There is a sample yaml also included you can use to see Pepr in your cluster. Here’s the quick steps to do that after pepr init:\n# cd to the newly-created Pepr module folder cd my-module-name # If you don't already have a local K8s cluster, you can set one up with k3d npm run k3d-setup # Launch pepr dev mode # If using another local K8s distro instead of k3d, use `pepr dev --host host.docker.internal` pepr dev # From another terminal, apply the sample yaml kubectl apply -f capabilities/hello-pepr.samples.yaml # Verify the configmaps were transformed using kubectl, k9s or another tool Create your custom Pepr Capabilities\nNow that you have confirmed Pepr is working, you can now create new capabilities. You’ll also want to disable the HelloPepr capability in your module (pepr.ts) before pushing to production. You can disable by commenting out or deleting the HelloPepr variable below:\nnew PeprModule(cfg, [ // Remove or comment the line below to disable the HelloPepr capability HelloPepr, // Your additional capabilities go here ]); Note: if you also delete the capabilities/hello-pepr.ts file, it will be added again on the next pepr update so you have the latest examples usages from the Pepr SDK. Therefore, it is sufficient to remove the entry from your pepr.ts module config.\nBuild and deploy the Pepr Module\nMost of the time, you’ll likely be iterating on a module with pepr dev for real-time feedback and validation Once you are ready to move beyond the local dev environment, Pepr provides deployment and build tools you can use.\npepr deploy - you can use this command to build your module and deploy it into any K8s cluster your current kubecontext has access to. This setup is ideal for CI systems during testing, but is not recommended for production use. See pepr deploy for more info.\nAdvanced Module Configuration By default, when you run pepr init, the module is not configured with any additional options. Currently, there are 3 options you can configure:\ndeferStart - if set to true, the module will not start automatically. You will need to call start() manually. This is useful if you want to do some additional setup before the module controller starts. You can also use this to change the default port that the controller listens on.\nbeforeHook - an optional callback that will be called before every request is processed. This is useful if you want to do some additional logging or validation before the request is processed.\nafterHook - an optional callback that will be called after every request is processed. This is useful if you want to do some additional logging or validation after the request is processed.\nYou can configure each of these by modifying the pepr.ts file in your module. Here’s an example of how you would configure each of these options:\nconst module = new PeprModule( cfg, [ // Your capabilities go here ], { deferStart: true, beforeHook: req =\u003e { // Any actions you want to perform before the request is processed, including modifying the request. }, afterHook: res =\u003e { // Any actions you want to perform after the request is processed, including modifying the response. }, } ); // Do any additional setup before starting the controller module.start(); ","categories":"","description":"","excerpt":"Each Pepr Module is it’s own Typescript project, produced by pepr …","ref":"/v0.21.0/module/","tags":"","title":"Pepr Module"},{"body":"Each Pepr Module is it’s own Typescript project, produced by pepr init. Typically a module is maintained by a unique group or system. For example, a module for internal Zarf mutations would be different from a module for Big Bang. An important idea with modules is that they are wholly independent of one another. This means that 2 different modules can be on completely different versions of Pepr and any other dependencies; their only interaction is through the standard K8s interfaces like any other webhook or controller.\nModule development lifecycle Create the module:\nUse pepr init to generate a new module.\nQuickly validate system setup:\nEvery new module includes a sample Pepr Capability called HelloPepr. By default, this capability is deployed and monitoring the pepr-demo namespace. There is a sample yaml also included you can use to see Pepr in your cluster. Here’s the quick steps to do that after pepr init:\n# cd to the newly-created Pepr module folder cd my-module-name # If you don't already have a local K8s cluster, you can set one up with k3d npm run k3d-setup # Launch pepr dev mode # If using another local K8s distro instead of k3d, use `pepr dev --host host.docker.internal` pepr dev # From another terminal, apply the sample yaml kubectl apply -f capabilities/hello-pepr.samples.yaml # Verify the configmaps were transformed using kubectl, k9s or another tool Create your custom Pepr Capabilities\nNow that you have confirmed Pepr is working, you can now create new capabilities. You’ll also want to disable the HelloPepr capability in your module (pepr.ts) before pushing to production. You can disable by commenting out or deleting the HelloPepr variable below:\nnew PeprModule(cfg, [ // Remove or comment the line below to disable the HelloPepr capability HelloPepr, // Your additional capabilities go here ]); Note: if you also delete the capabilities/hello-pepr.ts file, it will be added again on the next pepr update so you have the latest examples usages from the Pepr SDK. Therefore, it is sufficient to remove the entry from your pepr.ts module config.\nBuild and deploy the Pepr Module\nMost of the time, you’ll likely be iterating on a module with pepr dev for real-time feedback and validation Once you are ready to move beyond the local dev environment, Pepr provides deployment and build tools you can use.\npepr deploy - you can use this command to build your module and deploy it into any K8s cluster your current kubecontext has access to. This setup is ideal for CI systems during testing, but is not recommended for production use. See pepr deploy for more info.\nAdvanced Module Configuration By default, when you run pepr init, the module is not configured with any additional options. Currently, there are 3 options you can configure:\ndeferStart - if set to true, the module will not start automatically. You will need to call start() manually. This is useful if you want to do some additional setup before the module controller starts. You can also use this to change the default port that the controller listens on.\nbeforeHook - an optional callback that will be called before every request is processed. This is useful if you want to do some additional logging or validation before the request is processed.\nafterHook - an optional callback that will be called after every request is processed. This is useful if you want to do some additional logging or validation after the request is processed.\nYou can configure each of these by modifying the pepr.ts file in your module. Here’s an example of how you would configure each of these options:\nconst module = new PeprModule( cfg, [ // Your capabilities go here ], { deferStart: true, beforeHook: req =\u003e { // Any actions you want to perform before the request is processed, including modifying the request. }, afterHook: res =\u003e { // Any actions you want to perform after the request is processed, including modifying the response. }, } ); // Do any additional setup before starting the controller module.start(); ","categories":"","description":"","excerpt":"Each Pepr Module is it’s own Typescript project, produced by pepr …","ref":"/v0.21.1/module/","tags":"","title":"Pepr Module"},{"body":"The nature of admission controllers and general watch operations (the Mutate, Validate and Watch actions in Pepr) make some types of complex and long-running operations difficult. There are also times when you need to share data between different actions. While you could manually create your own K8s resources and manage their cleanup, this can be very hard to track and keep performant at scale.\nThe Pepr Store solves this by exposing a simple, Web Storage API-compatible mechanism for use within capabilities. Additionally, as Pepr runs multiple replicas of the admission controller along with a watch controller, the Pepr Store provides a unique way to share data between these different instances automatically.\nEach Pepr Capability has a Store instance that can be used to get, set and delete data as well as subscribe to any changes to the Store. Behind the scenes, all capability store instances in a single Pepr Module are stored within a single CRD in the cluster. This CRD is automatically created when the Pepr Module is deployed. Care is taken to make the read and write operations as efficient as possible by using K8s watches, batch processing and patch operations for writes.\nKey Features Asynchronous Key-Value Store: Provides an asynchronous interface for storing small amounts of data, making it ideal for sharing information between various actions and capabilities.\nWeb Storage API Compatibility: The store’s API is aligned with the standard Web Storage API, simplifying the learning curve.\nReal-time Updates: The .subscribe() and onReady() methods enable real-time updates, allowing you to react to changes in the data store instantaneously.\nAutomatic CRD Management: Each Pepr Module has its data stored within a single Custom Resource Definition (CRD) that is automatically created upon deployment.\nEfficient Operations: Pepr Store uses Kubernetes watches, batch processing, and patch operations to make read and write operations as efficient as possible.\nQuick Start // Example usage for Pepr Store Store.setItem(\"example-1\", \"was-here\"); Store.setItem(\"example-1-data\", JSON.stringify(request.Raw.data)); Store.onReady(data =\u003e { Log.info(data, \"Pepr Store Ready\"); }); const unsubscribe = Store.subscribe(data =\u003e { Log.info(data, \"Pepr Store Updated\"); unsubscribe(); }); API Reference Methods getItem(key: string): Retrieves a value by its key. Returns null if the key doesn’t exist. setItem(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. setItemAndWait(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. Returns a promise when the new key and value show up in the store. Should only be used on a Watch to avoid timeouts. removeItem(key: string): Deletes a key-value pair by its key. clear(): Clears all key-value pairs from the store. subscribe(listener: DataReceiver): Subscribes to store updates. onReady(callback: DataReceiver): Executes a callback when the store is ready. ","categories":"","description":"","excerpt":"The nature of admission controllers and general watch operations (the …","ref":"/main/store/","tags":"","title":"Pepr Store A Lightweight Key-Value Store for Pepr Modules"},{"body":"The nature of admission controllers and general watch operations (the Mutate, Validate and Watch actions in Pepr) make some types of complex and long-running operations difficult. There are also times when you need to share data between different actions. While you could manually create your own K8s resources and manage their cleanup, this can be very hard to track and keep performant at scale.\nThe Pepr Store solves this by exposing a simple, Web Storage API-compatible mechanism for use within capabilities. Additionally, as Pepr runs multiple replicas of the admission controller along with a watch controller, the Pepr Store provides a unique way to share data between these different instances automatically.\nEach Pepr Capability has a Store instance that can be used to get, set and delete data as well as subscribe to any changes to the Store. Behind the scenes, all capability store instances in a single Pepr Module are stored within a single CRD in the cluster. This CRD is automatically created when the Pepr Module is deployed. Care is taken to make the read and write operations as efficient as possible by using K8s watches, batch processing and patch operations for writes.\nKey Features Asynchronous Key-Value Store: Provides an asynchronous interface for storing small amounts of data, making it ideal for sharing information between various actions and capabilities.\nWeb Storage API Compatibility: The store’s API is aligned with the standard Web Storage API, simplifying the learning curve.\nReal-time Updates: The .subscribe() and onReady() methods enable real-time updates, allowing you to react to changes in the data store instantaneously.\nAutomatic CRD Management: Each Pepr Module has its data stored within a single Custom Resource Definition (CRD) that is automatically created upon deployment.\nEfficient Operations: Pepr Store uses Kubernetes watches, batch processing, and patch operations to make read and write operations as efficient as possible.\nQuick Start // Example usage for Pepr Store Store.setItem(\"example-1\", \"was-here\"); Store.setItem(\"example-1-data\", JSON.stringify(request.Raw.data)); Store.onReady(data =\u003e { Log.info(data, \"Pepr Store Ready\"); }); const unsubscribe = Store.subscribe(data =\u003e { Log.info(data, \"Pepr Store Updated\"); unsubscribe(); }); API Reference Methods getItem(key: string): Retrieves a value by its key. Returns null if the key doesn’t exist. setItem(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. setItemAndWait(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. Returns a promise when the new key and value show up in the store. Should only be used on a Watch to avoid timeouts. removeItem(key: string): Deletes a key-value pair by its key. clear(): Clears all key-value pairs from the store. subscribe(listener: DataReceiver): Subscribes to store updates. onReady(callback: DataReceiver): Executes a callback when the store is ready. ","categories":"","description":"","excerpt":"The nature of admission controllers and general watch operations (the …","ref":"/v0.19.0/store/","tags":"","title":"Pepr Store A Lightweight Key-Value Store for Pepr Modules"},{"body":"The nature of admission controllers and general watch operations (the Mutate, Validate and Watch actions in Pepr) make some types of complex and long-running operations difficult. There are also times when you need to share data between different actions. While you could manually create your own K8s resources and manage their cleanup, this can be very hard to track and keep performant at scale.\nThe Pepr Store solves this by exposing a simple, Web Storage API-compatible mechanism for use within capabilities. Additionally, as Pepr runs multiple replicas of the admission controller along with a watch controller, the Pepr Store provides a unique way to share data between these different instances automatically.\nEach Pepr Capability has a Store instance that can be used to get, set and delete data as well as subscribe to any changes to the Store. Behind the scenes, all capability store instances in a single Pepr Module are stored within a single CRD in the cluster. This CRD is automatically created when the Pepr Module is deployed. Care is taken to make the read and write operations as efficient as possible by using K8s watches, batch processing and patch operations for writes.\nKey Features Asynchronous Key-Value Store: Provides an asynchronous interface for storing small amounts of data, making it ideal for sharing information between various actions and capabilities.\nWeb Storage API Compatibility: The store’s API is aligned with the standard Web Storage API, simplifying the learning curve.\nReal-time Updates: The .subscribe() and onReady() methods enable real-time updates, allowing you to react to changes in the data store instantaneously.\nAutomatic CRD Management: Each Pepr Module has its data stored within a single Custom Resource Definition (CRD) that is automatically created upon deployment.\nEfficient Operations: Pepr Store uses Kubernetes watches, batch processing, and patch operations to make read and write operations as efficient as possible.\nQuick Start // Example usage for Pepr Store Store.setItem(\"example-1\", \"was-here\"); Store.setItem(\"example-1-data\", JSON.stringify(request.Raw.data)); Store.onReady(data =\u003e { Log.info(data, \"Pepr Store Ready\"); }); const unsubscribe = Store.subscribe(data =\u003e { Log.info(data, \"Pepr Store Updated\"); unsubscribe(); }); API Reference Methods getItem(key: string): Retrieves a value by its key. Returns null if the key doesn’t exist. setItem(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. setItemAndWait(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. Returns a promise when the new key and value show up in the store. Should only be used on a Watch to avoid timeouts. removeItem(key: string): Deletes a key-value pair by its key. clear(): Clears all key-value pairs from the store. subscribe(listener: DataReceiver): Subscribes to store updates. onReady(callback: DataReceiver): Executes a callback when the store is ready. ","categories":"","description":"","excerpt":"The nature of admission controllers and general watch operations (the …","ref":"/v0.20.0/store/","tags":"","title":"Pepr Store A Lightweight Key-Value Store for Pepr Modules"},{"body":"The nature of admission controllers and general watch operations (the Mutate, Validate and Watch actions in Pepr) make some types of complex and long-running operations difficult. There are also times when you need to share data between different actions. While you could manually create your own K8s resources and manage their cleanup, this can be very hard to track and keep performant at scale.\nThe Pepr Store solves this by exposing a simple, Web Storage API-compatible mechanism for use within capabilities. Additionally, as Pepr runs multiple replicas of the admission controller along with a watch controller, the Pepr Store provides a unique way to share data between these different instances automatically.\nEach Pepr Capability has a Store instance that can be used to get, set and delete data as well as subscribe to any changes to the Store. Behind the scenes, all capability store instances in a single Pepr Module are stored within a single CRD in the cluster. This CRD is automatically created when the Pepr Module is deployed. Care is taken to make the read and write operations as efficient as possible by using K8s watches, batch processing and patch operations for writes.\nKey Features Asynchronous Key-Value Store: Provides an asynchronous interface for storing small amounts of data, making it ideal for sharing information between various actions and capabilities.\nWeb Storage API Compatibility: The store’s API is aligned with the standard Web Storage API, simplifying the learning curve.\nReal-time Updates: The .subscribe() and onReady() methods enable real-time updates, allowing you to react to changes in the data store instantaneously.\nAutomatic CRD Management: Each Pepr Module has its data stored within a single Custom Resource Definition (CRD) that is automatically created upon deployment.\nEfficient Operations: Pepr Store uses Kubernetes watches, batch processing, and patch operations to make read and write operations as efficient as possible.\nQuick Start // Example usage for Pepr Store Store.setItem(\"example-1\", \"was-here\"); Store.setItem(\"example-1-data\", JSON.stringify(request.Raw.data)); Store.onReady(data =\u003e { Log.info(data, \"Pepr Store Ready\"); }); const unsubscribe = Store.subscribe(data =\u003e { Log.info(data, \"Pepr Store Updated\"); unsubscribe(); }); API Reference Methods getItem(key: string): Retrieves a value by its key. Returns null if the key doesn’t exist. setItem(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. setItemAndWait(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. Returns a promise when the new key and value show up in the store. Should only be used on a Watch to avoid timeouts. removeItem(key: string): Deletes a key-value pair by its key. clear(): Clears all key-value pairs from the store. subscribe(listener: DataReceiver): Subscribes to store updates. onReady(callback: DataReceiver): Executes a callback when the store is ready. ","categories":"","description":"","excerpt":"The nature of admission controllers and general watch operations (the …","ref":"/v0.20.1/store/","tags":"","title":"Pepr Store A Lightweight Key-Value Store for Pepr Modules"},{"body":"The nature of admission controllers and general watch operations (the Mutate, Validate and Watch actions in Pepr) make some types of complex and long-running operations difficult. There are also times when you need to share data between different actions. While you could manually create your own K8s resources and manage their cleanup, this can be very hard to track and keep performant at scale.\nThe Pepr Store solves this by exposing a simple, Web Storage API-compatible mechanism for use within capabilities. Additionally, as Pepr runs multiple replicas of the admission controller along with a watch controller, the Pepr Store provides a unique way to share data between these different instances automatically.\nEach Pepr Capability has a Store instance that can be used to get, set and delete data as well as subscribe to any changes to the Store. Behind the scenes, all capability store instances in a single Pepr Module are stored within a single CRD in the cluster. This CRD is automatically created when the Pepr Module is deployed. Care is taken to make the read and write operations as efficient as possible by using K8s watches, batch processing and patch operations for writes.\nKey Features Asynchronous Key-Value Store: Provides an asynchronous interface for storing small amounts of data, making it ideal for sharing information between various actions and capabilities.\nWeb Storage API Compatibility: The store’s API is aligned with the standard Web Storage API, simplifying the learning curve.\nReal-time Updates: The .subscribe() and onReady() methods enable real-time updates, allowing you to react to changes in the data store instantaneously.\nAutomatic CRD Management: Each Pepr Module has its data stored within a single Custom Resource Definition (CRD) that is automatically created upon deployment.\nEfficient Operations: Pepr Store uses Kubernetes watches, batch processing, and patch operations to make read and write operations as efficient as possible.\nQuick Start // Example usage for Pepr Store Store.setItem(\"example-1\", \"was-here\"); Store.setItem(\"example-1-data\", JSON.stringify(request.Raw.data)); Store.onReady(data =\u003e { Log.info(data, \"Pepr Store Ready\"); }); const unsubscribe = Store.subscribe(data =\u003e { Log.info(data, \"Pepr Store Updated\"); unsubscribe(); }); API Reference Methods getItem(key: string): Retrieves a value by its key. Returns null if the key doesn’t exist. setItem(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. setItemAndWait(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. Returns a promise when the new key and value show up in the store. Should only be used on a Watch to avoid timeouts. removeItem(key: string): Deletes a key-value pair by its key. clear(): Clears all key-value pairs from the store. subscribe(listener: DataReceiver): Subscribes to store updates. onReady(callback: DataReceiver): Executes a callback when the store is ready. ","categories":"","description":"","excerpt":"The nature of admission controllers and general watch operations (the …","ref":"/v0.20.2/store/","tags":"","title":"Pepr Store A Lightweight Key-Value Store for Pepr Modules"},{"body":"The nature of admission controllers and general watch operations (the Mutate, Validate and Watch actions in Pepr) make some types of complex and long-running operations difficult. There are also times when you need to share data between different actions. While you could manually create your own K8s resources and manage their cleanup, this can be very hard to track and keep performant at scale.\nThe Pepr Store solves this by exposing a simple, Web Storage API-compatible mechanism for use within capabilities. Additionally, as Pepr runs multiple replicas of the admission controller along with a watch controller, the Pepr Store provides a unique way to share data between these different instances automatically.\nEach Pepr Capability has a Store instance that can be used to get, set and delete data as well as subscribe to any changes to the Store. Behind the scenes, all capability store instances in a single Pepr Module are stored within a single CRD in the cluster. This CRD is automatically created when the Pepr Module is deployed. Care is taken to make the read and write operations as efficient as possible by using K8s watches, batch processing and patch operations for writes.\nKey Features Asynchronous Key-Value Store: Provides an asynchronous interface for storing small amounts of data, making it ideal for sharing information between various actions and capabilities.\nWeb Storage API Compatibility: The store’s API is aligned with the standard Web Storage API, simplifying the learning curve.\nReal-time Updates: The .subscribe() and onReady() methods enable real-time updates, allowing you to react to changes in the data store instantaneously.\nAutomatic CRD Management: Each Pepr Module has its data stored within a single Custom Resource Definition (CRD) that is automatically created upon deployment.\nEfficient Operations: Pepr Store uses Kubernetes watches, batch processing, and patch operations to make read and write operations as efficient as possible.\nQuick Start // Example usage for Pepr Store Store.setItem(\"example-1\", \"was-here\"); Store.setItem(\"example-1-data\", JSON.stringify(request.Raw.data)); Store.onReady(data =\u003e { Log.info(data, \"Pepr Store Ready\"); }); const unsubscribe = Store.subscribe(data =\u003e { Log.info(data, \"Pepr Store Updated\"); unsubscribe(); }); API Reference Methods getItem(key: string): Retrieves a value by its key. Returns null if the key doesn’t exist. setItem(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. setItemAndWait(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. Returns a promise when the new key and value show up in the store. Should only be used on a Watch to avoid timeouts. removeItem(key: string): Deletes a key-value pair by its key. clear(): Clears all key-value pairs from the store. subscribe(listener: DataReceiver): Subscribes to store updates. onReady(callback: DataReceiver): Executes a callback when the store is ready. ","categories":"","description":"","excerpt":"The nature of admission controllers and general watch operations (the …","ref":"/v0.20.3/store/","tags":"","title":"Pepr Store A Lightweight Key-Value Store for Pepr Modules"},{"body":"The nature of admission controllers and general watch operations (the Mutate, Validate and Watch actions in Pepr) make some types of complex and long-running operations difficult. There are also times when you need to share data between different actions. While you could manually create your own K8s resources and manage their cleanup, this can be very hard to track and keep performant at scale.\nThe Pepr Store solves this by exposing a simple, Web Storage API-compatible mechanism for use within capabilities. Additionally, as Pepr runs multiple replicas of the admission controller along with a watch controller, the Pepr Store provides a unique way to share data between these different instances automatically.\nEach Pepr Capability has a Store instance that can be used to get, set and delete data as well as subscribe to any changes to the Store. Behind the scenes, all capability store instances in a single Pepr Module are stored within a single CRD in the cluster. This CRD is automatically created when the Pepr Module is deployed. Care is taken to make the read and write operations as efficient as possible by using K8s watches, batch processing and patch operations for writes.\nKey Features Asynchronous Key-Value Store: Provides an asynchronous interface for storing small amounts of data, making it ideal for sharing information between various actions and capabilities.\nWeb Storage API Compatibility: The store’s API is aligned with the standard Web Storage API, simplifying the learning curve.\nReal-time Updates: The .subscribe() and onReady() methods enable real-time updates, allowing you to react to changes in the data store instantaneously.\nAutomatic CRD Management: Each Pepr Module has its data stored within a single Custom Resource Definition (CRD) that is automatically created upon deployment.\nEfficient Operations: Pepr Store uses Kubernetes watches, batch processing, and patch operations to make read and write operations as efficient as possible.\nQuick Start // Example usage for Pepr Store Store.setItem(\"example-1\", \"was-here\"); Store.setItem(\"example-1-data\", JSON.stringify(request.Raw.data)); Store.onReady(data =\u003e { Log.info(data, \"Pepr Store Ready\"); }); const unsubscribe = Store.subscribe(data =\u003e { Log.info(data, \"Pepr Store Updated\"); unsubscribe(); }); API Reference Methods getItem(key: string): Retrieves a value by its key. Returns null if the key doesn’t exist. setItem(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. setItemAndWait(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. Returns a promise when the new key and value show up in the store. Should only be used on a Watch to avoid timeouts. removeItem(key: string): Deletes a key-value pair by its key. clear(): Clears all key-value pairs from the store. subscribe(listener: DataReceiver): Subscribes to store updates. onReady(callback: DataReceiver): Executes a callback when the store is ready. ","categories":"","description":"","excerpt":"The nature of admission controllers and general watch operations (the …","ref":"/v0.21.0/store/","tags":"","title":"Pepr Store A Lightweight Key-Value Store for Pepr Modules"},{"body":"The nature of admission controllers and general watch operations (the Mutate, Validate and Watch actions in Pepr) make some types of complex and long-running operations difficult. There are also times when you need to share data between different actions. While you could manually create your own K8s resources and manage their cleanup, this can be very hard to track and keep performant at scale.\nThe Pepr Store solves this by exposing a simple, Web Storage API-compatible mechanism for use within capabilities. Additionally, as Pepr runs multiple replicas of the admission controller along with a watch controller, the Pepr Store provides a unique way to share data between these different instances automatically.\nEach Pepr Capability has a Store instance that can be used to get, set and delete data as well as subscribe to any changes to the Store. Behind the scenes, all capability store instances in a single Pepr Module are stored within a single CRD in the cluster. This CRD is automatically created when the Pepr Module is deployed. Care is taken to make the read and write operations as efficient as possible by using K8s watches, batch processing and patch operations for writes.\nKey Features Asynchronous Key-Value Store: Provides an asynchronous interface for storing small amounts of data, making it ideal for sharing information between various actions and capabilities.\nWeb Storage API Compatibility: The store’s API is aligned with the standard Web Storage API, simplifying the learning curve.\nReal-time Updates: The .subscribe() and onReady() methods enable real-time updates, allowing you to react to changes in the data store instantaneously.\nAutomatic CRD Management: Each Pepr Module has its data stored within a single Custom Resource Definition (CRD) that is automatically created upon deployment.\nEfficient Operations: Pepr Store uses Kubernetes watches, batch processing, and patch operations to make read and write operations as efficient as possible.\nQuick Start // Example usage for Pepr Store Store.setItem(\"example-1\", \"was-here\"); Store.setItem(\"example-1-data\", JSON.stringify(request.Raw.data)); Store.onReady(data =\u003e { Log.info(data, \"Pepr Store Ready\"); }); const unsubscribe = Store.subscribe(data =\u003e { Log.info(data, \"Pepr Store Updated\"); unsubscribe(); }); API Reference Methods getItem(key: string): Retrieves a value by its key. Returns null if the key doesn’t exist. setItem(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. setItemAndWait(key: string, value: string): Sets a value for a given key. Creates a new key-value pair if the key doesn’t exist. Returns a promise when the new key and value show up in the store. Should only be used on a Watch to avoid timeouts. removeItem(key: string): Deletes a key-value pair by its key. clear(): Clears all key-value pairs from the store. subscribe(listener: DataReceiver): Subscribes to store updates. onReady(callback: DataReceiver): Executes a callback when the store is ready. ","categories":"","description":"","excerpt":"The nature of admission controllers and general watch operations (the …","ref":"/v0.21.1/store/","tags":"","title":"Pepr Store A Lightweight Key-Value Store for Pepr Modules"},{"body":"During the build phase of Pepr (npx pepr build --rbac-mode [admin|scoped]), you have the option to specify the desired RBAC mode through specific flags. This allows fine-tuning the level of access granted based on requirements and preferences.\nModes admin\nnpx pepr build --rbac-mode admin Description: The service account is given cluster-admin permissions, granting it full, unrestricted access across the entire cluster. This can be useful for administrative tasks where broad permissions are necessary. However, use this mode with caution, as it can pose security risks if misused. This is the default mode.\nscoped\nnpx pepr build --rbac-mode scoped Description: The service account is provided just enough permissions to perform its required tasks, and no more. This mode is recommended for most use cases as it limits potential attack vectors and aligns with best practices in security. The admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole. See how in Updating the ClusterRole.\nDebugging RBAC Issues If encountering unexpected behaviors in Pepr while running in scoped mode, check to see if they are related to RBAC.\nCheck Deployment logs for RBAC errors: kubectl logs -n pepr-system -l app | jq # example output { \"level\": 50, \"time\": 1697983053758, \"pid\": 16, \"hostname\": \"pepr-static-test-watcher-745d65857d-pndg7\", \"data\": { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": {}, \"status\": \"Failure\", \"message\": \"configmaps \\\"pepr-ssa-demo\\\" is forbidden: User \\\"system:serviceaccount:pepr-system:pepr-static-test\\\" cannot patch resource \\\"configmaps\\\" in API group \\\"\\\" in the namespace \\\"pepr-demo-2\\\"\", \"reason\": \"Forbidden\", \"details\": { \"name\": \"pepr-ssa-demo\", \"kind\": \"configmaps\" }, \"code\": 403 }, \"ok\": false, \"status\": 403, \"statusText\": \"Forbidden\", \"msg\": \"Dooes the ServiceAccount permissions to CREATE and PATCH this ConfigMap?\" } Verify ServiceAccount Permissions with kubectl auth can-i SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') # Can i create configmaps as the service account in pepr-demo-2? kubectl auth can-i create cm --as=system:serviceaccount:pepr-system:$SA -n pepr-demo-2 # example output: no Describe the ClusterRole SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') kubectl describe clusterrole $SA # example output: Name: pepr-static-test Labels: \u003cnone\u003e Annotations: \u003cnone\u003e PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- peprstores.pepr.dev [] [] [create delete get list patch update watch] configmaps [] [] [watch] namespaces [] [] [watch] Updating the ClusterRole As discussed in the Modes section, the admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole.\nStep 1: Figure out the desired permissions. (kubectl create clusterrole --help is a good place to start figuring out the syntax)\nkubectl create clusterrole configMapApplier --verb=create,patch --resource=configmap --dry-run=client -oyaml # example output apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: creationTimestamp: null name: configMapApplier rules: - apiGroups: - \"\" resources: - configmaps verbs: - create - patch Step 2: Update the ClusterRole in the dist folder.\n... apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pepr-static-test rules: - apiGroups: - pepr.dev resources: - peprstores verbs: - create - get - patch - watch - apiGroups: - '' resources: - namespaces verbs: - watch - apiGroups: - '' resources: - configmaps verbs: - watch - create # New - patch # New ... Step 3: Apply the updated configuration\n","categories":"","description":"","excerpt":"During the build phase of Pepr (npx pepr build --rbac-mode …","ref":"/main/rbac/","tags":"","title":"RBAC Modes"},{"body":"During the build phase of Pepr (npx pepr build --rbac-mode [admin|scoped]), you have the option to specify the desired RBAC mode through specific flags. This allows fine-tuning the level of access granted based on requirements and preferences.\nModes admin\nnpx pepr build --rbac-mode admin Description: The service account is given cluster-admin permissions, granting it full, unrestricted access across the entire cluster. This can be useful for administrative tasks where broad permissions are necessary. However, use this mode with caution, as it can pose security risks if misused. This is the default mode.\nscoped\nnpx pepr build --rbac-mode scoped Description: The service account is provided just enough permissions to perform its required tasks, and no more. This mode is recommended for most use cases as it limits potential attack vectors and aligns with best practices in security. The admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole. See how in Updating the ClusterRole.\nDebugging RBAC Issues If encountering unexpected behaviors in Pepr while running in scoped mode, check to see if they are related to RBAC.\nCheck Deployment logs for RBAC errors: kubectl logs -n pepr-system -l app | jq # example output { \"level\": 50, \"time\": 1697983053758, \"pid\": 16, \"hostname\": \"pepr-static-test-watcher-745d65857d-pndg7\", \"data\": { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": {}, \"status\": \"Failure\", \"message\": \"configmaps \\\"pepr-ssa-demo\\\" is forbidden: User \\\"system:serviceaccount:pepr-system:pepr-static-test\\\" cannot patch resource \\\"configmaps\\\" in API group \\\"\\\" in the namespace \\\"pepr-demo-2\\\"\", \"reason\": \"Forbidden\", \"details\": { \"name\": \"pepr-ssa-demo\", \"kind\": \"configmaps\" }, \"code\": 403 }, \"ok\": false, \"status\": 403, \"statusText\": \"Forbidden\", \"msg\": \"Dooes the ServiceAccount permissions to CREATE and PATCH this ConfigMap?\" } Verify ServiceAccount Permissions with kubectl auth can-i SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') # Can i create configmaps as the service account in pepr-demo-2? kubectl auth can-i create cm --as=system:serviceaccount:pepr-system:$SA -n pepr-demo-2 # example output: no Describe the ClusterRole SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') kubectl describe clusterrole $SA # example output: Name: pepr-static-test Labels: \u003cnone\u003e Annotations: \u003cnone\u003e PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- peprstores.pepr.dev [] [] [create delete get list patch update watch] configmaps [] [] [watch] namespaces [] [] [watch] Updating the ClusterRole As discussed in the Modes section, the admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole.\nStep 1: Figure out the desired permissions. (kubectl create clusterrole --help is a good place to start figuring out the syntax)\nkubectl create clusterrole configMapApplier --verb=create,patch --resource=configmap --dry-run=client -oyaml # example output apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: creationTimestamp: null name: configMapApplier rules: - apiGroups: - \"\" resources: - configmaps verbs: - create - patch Step 2: Update the ClusterRole in the dist folder.\n... apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pepr-static-test rules: - apiGroups: - pepr.dev resources: - peprstores verbs: - create - get - patch - watch - apiGroups: - '' resources: - namespaces verbs: - watch - apiGroups: - '' resources: - configmaps verbs: - watch - create # New - patch # New ... Step 3: Apply the updated configuration\n","categories":"","description":"","excerpt":"During the build phase of Pepr (npx pepr build --rbac-mode …","ref":"/v0.19.0/rbac/","tags":"","title":"RBAC Modes"},{"body":"During the build phase of Pepr (npx pepr build --rbac-mode [admin|scoped]), you have the option to specify the desired RBAC mode through specific flags. This allows fine-tuning the level of access granted based on requirements and preferences.\nModes admin\nnpx pepr build --rbac-mode admin Description: The service account is given cluster-admin permissions, granting it full, unrestricted access across the entire cluster. This can be useful for administrative tasks where broad permissions are necessary. However, use this mode with caution, as it can pose security risks if misused. This is the default mode.\nscoped\nnpx pepr build --rbac-mode scoped Description: The service account is provided just enough permissions to perform its required tasks, and no more. This mode is recommended for most use cases as it limits potential attack vectors and aligns with best practices in security. The admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole. See how in Updating the ClusterRole.\nDebugging RBAC Issues If encountering unexpected behaviors in Pepr while running in scoped mode, check to see if they are related to RBAC.\nCheck Deployment logs for RBAC errors: kubectl logs -n pepr-system -l app | jq # example output { \"level\": 50, \"time\": 1697983053758, \"pid\": 16, \"hostname\": \"pepr-static-test-watcher-745d65857d-pndg7\", \"data\": { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": {}, \"status\": \"Failure\", \"message\": \"configmaps \\\"pepr-ssa-demo\\\" is forbidden: User \\\"system:serviceaccount:pepr-system:pepr-static-test\\\" cannot patch resource \\\"configmaps\\\" in API group \\\"\\\" in the namespace \\\"pepr-demo-2\\\"\", \"reason\": \"Forbidden\", \"details\": { \"name\": \"pepr-ssa-demo\", \"kind\": \"configmaps\" }, \"code\": 403 }, \"ok\": false, \"status\": 403, \"statusText\": \"Forbidden\", \"msg\": \"Dooes the ServiceAccount permissions to CREATE and PATCH this ConfigMap?\" } Verify ServiceAccount Permissions with kubectl auth can-i SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') # Can i create configmaps as the service account in pepr-demo-2? kubectl auth can-i create cm --as=system:serviceaccount:pepr-system:$SA -n pepr-demo-2 # example output: no Describe the ClusterRole SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') kubectl describe clusterrole $SA # example output: Name: pepr-static-test Labels: \u003cnone\u003e Annotations: \u003cnone\u003e PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- peprstores.pepr.dev [] [] [create delete get list patch update watch] configmaps [] [] [watch] namespaces [] [] [watch] Updating the ClusterRole As discussed in the Modes section, the admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole.\nStep 1: Figure out the desired permissions. (kubectl create clusterrole --help is a good place to start figuring out the syntax)\nkubectl create clusterrole configMapApplier --verb=create,patch --resource=configmap --dry-run=client -oyaml # example output apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: creationTimestamp: null name: configMapApplier rules: - apiGroups: - \"\" resources: - configmaps verbs: - create - patch Step 2: Update the ClusterRole in the dist folder.\n... apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pepr-static-test rules: - apiGroups: - pepr.dev resources: - peprstores verbs: - create - get - patch - watch - apiGroups: - '' resources: - namespaces verbs: - watch - apiGroups: - '' resources: - configmaps verbs: - watch - create # New - patch # New ... Step 3: Apply the updated configuration\n","categories":"","description":"","excerpt":"During the build phase of Pepr (npx pepr build --rbac-mode …","ref":"/v0.20.0/rbac/","tags":"","title":"RBAC Modes"},{"body":"During the build phase of Pepr (npx pepr build --rbac-mode [admin|scoped]), you have the option to specify the desired RBAC mode through specific flags. This allows fine-tuning the level of access granted based on requirements and preferences.\nModes admin\nnpx pepr build --rbac-mode admin Description: The service account is given cluster-admin permissions, granting it full, unrestricted access across the entire cluster. This can be useful for administrative tasks where broad permissions are necessary. However, use this mode with caution, as it can pose security risks if misused. This is the default mode.\nscoped\nnpx pepr build --rbac-mode scoped Description: The service account is provided just enough permissions to perform its required tasks, and no more. This mode is recommended for most use cases as it limits potential attack vectors and aligns with best practices in security. The admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole. See how in Updating the ClusterRole.\nDebugging RBAC Issues If encountering unexpected behaviors in Pepr while running in scoped mode, check to see if they are related to RBAC.\nCheck Deployment logs for RBAC errors: kubectl logs -n pepr-system -l app | jq # example output { \"level\": 50, \"time\": 1697983053758, \"pid\": 16, \"hostname\": \"pepr-static-test-watcher-745d65857d-pndg7\", \"data\": { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": {}, \"status\": \"Failure\", \"message\": \"configmaps \\\"pepr-ssa-demo\\\" is forbidden: User \\\"system:serviceaccount:pepr-system:pepr-static-test\\\" cannot patch resource \\\"configmaps\\\" in API group \\\"\\\" in the namespace \\\"pepr-demo-2\\\"\", \"reason\": \"Forbidden\", \"details\": { \"name\": \"pepr-ssa-demo\", \"kind\": \"configmaps\" }, \"code\": 403 }, \"ok\": false, \"status\": 403, \"statusText\": \"Forbidden\", \"msg\": \"Dooes the ServiceAccount permissions to CREATE and PATCH this ConfigMap?\" } Verify ServiceAccount Permissions with kubectl auth can-i SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') # Can i create configmaps as the service account in pepr-demo-2? kubectl auth can-i create cm --as=system:serviceaccount:pepr-system:$SA -n pepr-demo-2 # example output: no Describe the ClusterRole SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') kubectl describe clusterrole $SA # example output: Name: pepr-static-test Labels: \u003cnone\u003e Annotations: \u003cnone\u003e PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- peprstores.pepr.dev [] [] [create delete get list patch update watch] configmaps [] [] [watch] namespaces [] [] [watch] Updating the ClusterRole As discussed in the Modes section, the admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole.\nStep 1: Figure out the desired permissions. (kubectl create clusterrole --help is a good place to start figuring out the syntax)\nkubectl create clusterrole configMapApplier --verb=create,patch --resource=configmap --dry-run=client -oyaml # example output apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: creationTimestamp: null name: configMapApplier rules: - apiGroups: - \"\" resources: - configmaps verbs: - create - patch Step 2: Update the ClusterRole in the dist folder.\n... apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pepr-static-test rules: - apiGroups: - pepr.dev resources: - peprstores verbs: - create - get - patch - watch - apiGroups: - '' resources: - namespaces verbs: - watch - apiGroups: - '' resources: - configmaps verbs: - watch - create # New - patch # New ... Step 3: Apply the updated configuration\n","categories":"","description":"","excerpt":"During the build phase of Pepr (npx pepr build --rbac-mode …","ref":"/v0.20.1/rbac/","tags":"","title":"RBAC Modes"},{"body":"During the build phase of Pepr (npx pepr build --rbac-mode [admin|scoped]), you have the option to specify the desired RBAC mode through specific flags. This allows fine-tuning the level of access granted based on requirements and preferences.\nModes admin\nnpx pepr build --rbac-mode admin Description: The service account is given cluster-admin permissions, granting it full, unrestricted access across the entire cluster. This can be useful for administrative tasks where broad permissions are necessary. However, use this mode with caution, as it can pose security risks if misused. This is the default mode.\nscoped\nnpx pepr build --rbac-mode scoped Description: The service account is provided just enough permissions to perform its required tasks, and no more. This mode is recommended for most use cases as it limits potential attack vectors and aligns with best practices in security. The admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole. See how in Updating the ClusterRole.\nDebugging RBAC Issues If encountering unexpected behaviors in Pepr while running in scoped mode, check to see if they are related to RBAC.\nCheck Deployment logs for RBAC errors: kubectl logs -n pepr-system -l app | jq # example output { \"level\": 50, \"time\": 1697983053758, \"pid\": 16, \"hostname\": \"pepr-static-test-watcher-745d65857d-pndg7\", \"data\": { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": {}, \"status\": \"Failure\", \"message\": \"configmaps \\\"pepr-ssa-demo\\\" is forbidden: User \\\"system:serviceaccount:pepr-system:pepr-static-test\\\" cannot patch resource \\\"configmaps\\\" in API group \\\"\\\" in the namespace \\\"pepr-demo-2\\\"\", \"reason\": \"Forbidden\", \"details\": { \"name\": \"pepr-ssa-demo\", \"kind\": \"configmaps\" }, \"code\": 403 }, \"ok\": false, \"status\": 403, \"statusText\": \"Forbidden\", \"msg\": \"Dooes the ServiceAccount permissions to CREATE and PATCH this ConfigMap?\" } Verify ServiceAccount Permissions with kubectl auth can-i SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') # Can i create configmaps as the service account in pepr-demo-2? kubectl auth can-i create cm --as=system:serviceaccount:pepr-system:$SA -n pepr-demo-2 # example output: no Describe the ClusterRole SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') kubectl describe clusterrole $SA # example output: Name: pepr-static-test Labels: \u003cnone\u003e Annotations: \u003cnone\u003e PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- peprstores.pepr.dev [] [] [create delete get list patch update watch] configmaps [] [] [watch] namespaces [] [] [watch] Updating the ClusterRole As discussed in the Modes section, the admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole.\nStep 1: Figure out the desired permissions. (kubectl create clusterrole --help is a good place to start figuring out the syntax)\nkubectl create clusterrole configMapApplier --verb=create,patch --resource=configmap --dry-run=client -oyaml # example output apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: creationTimestamp: null name: configMapApplier rules: - apiGroups: - \"\" resources: - configmaps verbs: - create - patch Step 2: Update the ClusterRole in the dist folder.\n... apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pepr-static-test rules: - apiGroups: - pepr.dev resources: - peprstores verbs: - create - get - patch - watch - apiGroups: - '' resources: - namespaces verbs: - watch - apiGroups: - '' resources: - configmaps verbs: - watch - create # New - patch # New ... Step 3: Apply the updated configuration\n","categories":"","description":"","excerpt":"During the build phase of Pepr (npx pepr build --rbac-mode …","ref":"/v0.20.2/rbac/","tags":"","title":"RBAC Modes"},{"body":"During the build phase of Pepr (npx pepr build --rbac-mode [admin|scoped]), you have the option to specify the desired RBAC mode through specific flags. This allows fine-tuning the level of access granted based on requirements and preferences.\nModes admin\nnpx pepr build --rbac-mode admin Description: The service account is given cluster-admin permissions, granting it full, unrestricted access across the entire cluster. This can be useful for administrative tasks where broad permissions are necessary. However, use this mode with caution, as it can pose security risks if misused. This is the default mode.\nscoped\nnpx pepr build --rbac-mode scoped Description: The service account is provided just enough permissions to perform its required tasks, and no more. This mode is recommended for most use cases as it limits potential attack vectors and aligns with best practices in security. The admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole. See how in Updating the ClusterRole.\nDebugging RBAC Issues If encountering unexpected behaviors in Pepr while running in scoped mode, check to see if they are related to RBAC.\nCheck Deployment logs for RBAC errors: kubectl logs -n pepr-system -l app | jq # example output { \"level\": 50, \"time\": 1697983053758, \"pid\": 16, \"hostname\": \"pepr-static-test-watcher-745d65857d-pndg7\", \"data\": { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": {}, \"status\": \"Failure\", \"message\": \"configmaps \\\"pepr-ssa-demo\\\" is forbidden: User \\\"system:serviceaccount:pepr-system:pepr-static-test\\\" cannot patch resource \\\"configmaps\\\" in API group \\\"\\\" in the namespace \\\"pepr-demo-2\\\"\", \"reason\": \"Forbidden\", \"details\": { \"name\": \"pepr-ssa-demo\", \"kind\": \"configmaps\" }, \"code\": 403 }, \"ok\": false, \"status\": 403, \"statusText\": \"Forbidden\", \"msg\": \"Dooes the ServiceAccount permissions to CREATE and PATCH this ConfigMap?\" } Verify ServiceAccount Permissions with kubectl auth can-i SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') # Can i create configmaps as the service account in pepr-demo-2? kubectl auth can-i create cm --as=system:serviceaccount:pepr-system:$SA -n pepr-demo-2 # example output: no Describe the ClusterRole SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') kubectl describe clusterrole $SA # example output: Name: pepr-static-test Labels: \u003cnone\u003e Annotations: \u003cnone\u003e PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- peprstores.pepr.dev [] [] [create delete get list patch update watch] configmaps [] [] [watch] namespaces [] [] [watch] Updating the ClusterRole As discussed in the Modes section, the admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole.\nStep 1: Figure out the desired permissions. (kubectl create clusterrole --help is a good place to start figuring out the syntax)\nkubectl create clusterrole configMapApplier --verb=create,patch --resource=configmap --dry-run=client -oyaml # example output apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: creationTimestamp: null name: configMapApplier rules: - apiGroups: - \"\" resources: - configmaps verbs: - create - patch Step 2: Update the ClusterRole in the dist folder.\n... apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pepr-static-test rules: - apiGroups: - pepr.dev resources: - peprstores verbs: - create - get - patch - watch - apiGroups: - '' resources: - namespaces verbs: - watch - apiGroups: - '' resources: - configmaps verbs: - watch - create # New - patch # New ... Step 3: Apply the updated configuration\n","categories":"","description":"","excerpt":"During the build phase of Pepr (npx pepr build --rbac-mode …","ref":"/v0.20.3/rbac/","tags":"","title":"RBAC Modes"},{"body":"During the build phase of Pepr (npx pepr build --rbac-mode [admin|scoped]), you have the option to specify the desired RBAC mode through specific flags. This allows fine-tuning the level of access granted based on requirements and preferences.\nModes admin\nnpx pepr build --rbac-mode admin Description: The service account is given cluster-admin permissions, granting it full, unrestricted access across the entire cluster. This can be useful for administrative tasks where broad permissions are necessary. However, use this mode with caution, as it can pose security risks if misused. This is the default mode.\nscoped\nnpx pepr build --rbac-mode scoped Description: The service account is provided just enough permissions to perform its required tasks, and no more. This mode is recommended for most use cases as it limits potential attack vectors and aligns with best practices in security. The admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole. See how in Updating the ClusterRole.\nDebugging RBAC Issues If encountering unexpected behaviors in Pepr while running in scoped mode, check to see if they are related to RBAC.\nCheck Deployment logs for RBAC errors: kubectl logs -n pepr-system -l app | jq # example output { \"level\": 50, \"time\": 1697983053758, \"pid\": 16, \"hostname\": \"pepr-static-test-watcher-745d65857d-pndg7\", \"data\": { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": {}, \"status\": \"Failure\", \"message\": \"configmaps \\\"pepr-ssa-demo\\\" is forbidden: User \\\"system:serviceaccount:pepr-system:pepr-static-test\\\" cannot patch resource \\\"configmaps\\\" in API group \\\"\\\" in the namespace \\\"pepr-demo-2\\\"\", \"reason\": \"Forbidden\", \"details\": { \"name\": \"pepr-ssa-demo\", \"kind\": \"configmaps\" }, \"code\": 403 }, \"ok\": false, \"status\": 403, \"statusText\": \"Forbidden\", \"msg\": \"Dooes the ServiceAccount permissions to CREATE and PATCH this ConfigMap?\" } Verify ServiceAccount Permissions with kubectl auth can-i SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') # Can i create configmaps as the service account in pepr-demo-2? kubectl auth can-i create cm --as=system:serviceaccount:pepr-system:$SA -n pepr-demo-2 # example output: no Describe the ClusterRole SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') kubectl describe clusterrole $SA # example output: Name: pepr-static-test Labels: \u003cnone\u003e Annotations: \u003cnone\u003e PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- peprstores.pepr.dev [] [] [create delete get list patch update watch] configmaps [] [] [watch] namespaces [] [] [watch] Updating the ClusterRole As discussed in the Modes section, the admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole.\nStep 1: Figure out the desired permissions. (kubectl create clusterrole --help is a good place to start figuring out the syntax)\nkubectl create clusterrole configMapApplier --verb=create,patch --resource=configmap --dry-run=client -oyaml # example output apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: creationTimestamp: null name: configMapApplier rules: - apiGroups: - \"\" resources: - configmaps verbs: - create - patch Step 2: Update the ClusterRole in the dist folder.\n... apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pepr-static-test rules: - apiGroups: - pepr.dev resources: - peprstores verbs: - create - get - patch - watch - apiGroups: - '' resources: - namespaces verbs: - watch - apiGroups: - '' resources: - configmaps verbs: - watch - create # New - patch # New ... Step 3: Apply the updated configuration\n","categories":"","description":"","excerpt":"During the build phase of Pepr (npx pepr build --rbac-mode …","ref":"/v0.21.0/rbac/","tags":"","title":"RBAC Modes"},{"body":"During the build phase of Pepr (npx pepr build --rbac-mode [admin|scoped]), you have the option to specify the desired RBAC mode through specific flags. This allows fine-tuning the level of access granted based on requirements and preferences.\nModes admin\nnpx pepr build --rbac-mode admin Description: The service account is given cluster-admin permissions, granting it full, unrestricted access across the entire cluster. This can be useful for administrative tasks where broad permissions are necessary. However, use this mode with caution, as it can pose security risks if misused. This is the default mode.\nscoped\nnpx pepr build --rbac-mode scoped Description: The service account is provided just enough permissions to perform its required tasks, and no more. This mode is recommended for most use cases as it limits potential attack vectors and aligns with best practices in security. The admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole. See how in Updating the ClusterRole.\nDebugging RBAC Issues If encountering unexpected behaviors in Pepr while running in scoped mode, check to see if they are related to RBAC.\nCheck Deployment logs for RBAC errors: kubectl logs -n pepr-system -l app | jq # example output { \"level\": 50, \"time\": 1697983053758, \"pid\": 16, \"hostname\": \"pepr-static-test-watcher-745d65857d-pndg7\", \"data\": { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": {}, \"status\": \"Failure\", \"message\": \"configmaps \\\"pepr-ssa-demo\\\" is forbidden: User \\\"system:serviceaccount:pepr-system:pepr-static-test\\\" cannot patch resource \\\"configmaps\\\" in API group \\\"\\\" in the namespace \\\"pepr-demo-2\\\"\", \"reason\": \"Forbidden\", \"details\": { \"name\": \"pepr-ssa-demo\", \"kind\": \"configmaps\" }, \"code\": 403 }, \"ok\": false, \"status\": 403, \"statusText\": \"Forbidden\", \"msg\": \"Dooes the ServiceAccount permissions to CREATE and PATCH this ConfigMap?\" } Verify ServiceAccount Permissions with kubectl auth can-i SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') # Can i create configmaps as the service account in pepr-demo-2? kubectl auth can-i create cm --as=system:serviceaccount:pepr-system:$SA -n pepr-demo-2 # example output: no Describe the ClusterRole SA=$(kubectl get deploy -n pepr-system -o=jsonpath='{range .items[0]}{.spec.template.spec.serviceAccountName}{\"\\n\"}{end}') kubectl describe clusterrole $SA # example output: Name: pepr-static-test Labels: \u003cnone\u003e Annotations: \u003cnone\u003e PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- peprstores.pepr.dev [] [] [create delete get list patch update watch] configmaps [] [] [watch] namespaces [] [] [watch] Updating the ClusterRole As discussed in the Modes section, the admission controller’s primary mutating or validating action doesn’t require a ClusterRole (as the request is not persisted or executed while passing through admission control), if you have a use case where the admission controller’s logic involves reading other Kubernetes resources or taking additional actions beyond just validating, mutating, or watching the incoming request, appropriate RBAC settings should be reflected in the ClusterRole.\nStep 1: Figure out the desired permissions. (kubectl create clusterrole --help is a good place to start figuring out the syntax)\nkubectl create clusterrole configMapApplier --verb=create,patch --resource=configmap --dry-run=client -oyaml # example output apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: creationTimestamp: null name: configMapApplier rules: - apiGroups: - \"\" resources: - configmaps verbs: - create - patch Step 2: Update the ClusterRole in the dist folder.\n... apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pepr-static-test rules: - apiGroups: - pepr.dev resources: - peprstores verbs: - create - get - patch - watch - apiGroups: - '' resources: - namespaces verbs: - watch - apiGroups: - '' resources: - configmaps verbs: - watch - create # New - patch # New ... Step 3: Apply the updated configuration\n","categories":"","description":"","excerpt":"During the build phase of Pepr (npx pepr build --rbac-mode …","ref":"/v0.21.1/rbac/","tags":"","title":"RBAC Modes"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission to save Kubernetes from the tyranny of YAML, intimidating glue code, bash scripts, and other makeshift solutions. As a Kubernetes controller, Pepr empowers you to define Kubernetes transformations using TypeScript, without software development expertise thanks to plain-english configurations. Pepr transforms a patchwork of forks, scripts, overlays, and other chaos into a cohesive, well-structured, and maintainable system. With Pepr, you can seamlessly transition IT ops tribal knowledge into code, simplifying documentation, testing, validation, and coordination of changes for a more predictable outcome.\nNote: Pepr is still in active development so breaking changes may occur, but will be documented in release notes. Features Zero-config K8s webhook mutations and validations Automatic leader-elected K8s resource watching Lightweight async key-value store backed by K8s for stateful operations with the Pepr Store Human-readable fluent API for generating Pepr Capabilities A fluent API for creating/modifying/watching and server-side applying K8s resources via Kubernetes Fluent Client Generate new K8s resources based off of cluster resource changes Perform other exec/API calls based off of cluster resources changes or any other arbitrary schedule Out of the box airgap support with Zarf Entire NPM ecosystem available for advanced operations Realtime K8s debugging system for testing/reacting to cluster changes Controller network isolation and tamper-resistent module execution Automatic least-privilege RBAC generation soon AMD64 and ARM64 support Example Pepr Action This quick sample shows how to react to a ConfigMap being created or updated in the cluster. It adds a label and annotation to the ConfigMap and adds some data to the ConfigMap. It also creates a Validating Webhook to make sure the “pepr” label still exists. Finally, after the ConfigMap is created, it logs a message to the Pepr controller and creates or updates a separate ConfigMap with the kubernetes-fluent-client using server-side apply. For more details see actions section.\nWhen(a.ConfigMap) .IsCreatedOrUpdated() .InNamespace(\"pepr-demo\") .WithLabel(\"unicorn\", \"rainbow\") // Create a Mutate Action for the ConfigMap .Mutate(request =\u003e { // Add a label and annotation to the ConfigMap request.SetLabel(\"pepr\", \"was-here\").SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Add some data to the ConfigMap request.Raw.data[\"doug-says\"] = \"Pepr is awesome!\"; // Log a message to the Pepr controller logs Log.info(\"A 🦄 ConfigMap was created or updated:\"); }) // Create a Validate Action for the ConfigMap .Validate(request =\u003e { // Validate the ConfigMap has a specific label if (request.HasLabel(\"pepr\")) { return request.Approve(); } // Reject the ConfigMap if it doesn't have the label return request.Deny(\"ConfigMap must have a unicorn label\"); }) // Watch behaves like controller-runtime's Manager.Watch() .Watch(async (cm, phase) =\u003e { Log.info(cm, `ConfigMap was ${phase}.`); // Apply a ConfigMap using K8s server-side apply (will create or update) await K8s(kind.ConfigMap).Apply({ metadata: { name: \"pepr-ssa-demo\", namespace: \"pepr-demo-2\", }, data: { uid: cm.metadata.uid, }, }); }); Prerequisites Node.js v18.0.0+ (even-numbered releases only)\nTo ensure compatability and optimal performance, it is recommended to use even-numbered releases of Node.js as they are stable releases and receive long-term support for three years. Odd-numbered releases are experimental and may not be supported by certain libraries utilized in Pepr. npm v10.1.0+\nRecommended (optional) tools:\nVisual Studio Code for inline debugging and Pepr Capabilities creation. A Kubernetes cluster for npx pepr dev. Pepr modules include npm run k3d-setup if you want to test locally with K3d and Docker. Wow too many words! tl;dr; # Create a new Pepr Module npx pepr init # If you already have a Kind or K3d cluster you want to use, skip this step npm run k3d-setup # Start playing with Pepr now # If using another local K8s distro instead of k3d, run `npx pepr dev --host host.docker.internal` npx pepr dev kubectl apply -f capabilities/hello-pepr.samples.yaml # Be amazed and ⭐️ this repo Concepts Module A module is the top-level collection of capabilities. It is a single, complete TypeScript project that includes an entry point to load all the configuration and capabilities, along with their actions. During the Pepr build process, each module produces a unique Kubernetes MutatingWebhookConfiguration and ValidatingWebhookConfiguration, along with a secret containing the transpiled and compressed TypeScript code. The webhooks and secret are deployed into the Kubernetes cluster with their own isolated controller.\nSee Module for more details.\nCapability A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nSee Capabilities for more details.\nAction Action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in from Kubernetes. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nThere are both Mutate() and Validate() Actions that can be used to modify or validate Kubernetes resources within the admission controller lifecycle. There is also a Watch() Action that can be used to watch for changes to Kubernetes resources that already exist.\nSee actions for more details.\nLogical Pepr Flow Source Diagram\nTypeScript TypeScript is a strongly typed, object-oriented programming language built on top of JavaScript. It provides optional static typing and a rich type system, allowing developers to write more robust code. TypeScript is transpiled to JavaScript, enabling it to run in any environment that supports JavaScript. Pepr allows you to use JavaScript or TypeScript to write capabilities, but TypeScript is recommended for its type safety and rich type system. You can learn more about TypeScript here.\n","categories":"","description":"","excerpt":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission …","ref":"/v0.19.0/","tags":"","title":"v0.19.0"},{"body":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission to save Kubernetes from the tyranny of YAML, intimidating glue code, bash scripts, and other makeshift solutions. As a Kubernetes controller, Pepr empowers you to define Kubernetes transformations using TypeScript, without software development expertise thanks to plain-english configurations. Pepr transforms a patchwork of forks, scripts, overlays, and other chaos into a cohesive, well-structured, and maintainable system. With Pepr, you can seamlessly transition IT ops tribal knowledge into code, simplifying documentation, testing, validation, and coordination of changes for a more predictable outcome.\nNote: Pepr is still in active development so breaking changes may occur, but will be documented in release notes. Features Zero-config K8s webhook mutations and validations Automatic leader-elected K8s resource watching Lightweight async key-value store backed by K8s for stateful operations with the Pepr Store Human-readable fluent API for generating Pepr Capabilities A fluent API for creating/modifying/watching and server-side applying K8s resources via Kubernetes Fluent Client Generate new K8s resources based off of cluster resource changes Perform other exec/API calls based off of cluster resources changes or any other arbitrary schedule Out of the box airgap support with Zarf Entire NPM ecosystem available for advanced operations Realtime K8s debugging system for testing/reacting to cluster changes Controller network isolation and tamper-resistent module execution Least-privilege RBAC generation AMD64 and ARM64 support Example Pepr Action This quick sample shows how to react to a ConfigMap being created or updated in the cluster. It adds a label and annotation to the ConfigMap and adds some data to the ConfigMap. It also creates a Validating Webhook to make sure the “pepr” label still exists. Finally, after the ConfigMap is created, it logs a message to the Pepr controller and creates or updates a separate ConfigMap with the kubernetes-fluent-client using server-side apply. For more details see actions section.\nWhen(a.ConfigMap) .IsCreatedOrUpdated() .InNamespace(\"pepr-demo\") .WithLabel(\"unicorn\", \"rainbow\") // Create a Mutate Action for the ConfigMap .Mutate(request =\u003e { // Add a label and annotation to the ConfigMap request.SetLabel(\"pepr\", \"was-here\").SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Add some data to the ConfigMap request.Raw.data[\"doug-says\"] = \"Pepr is awesome!\"; // Log a message to the Pepr controller logs Log.info(\"A 🦄 ConfigMap was created or updated:\"); }) // Create a Validate Action for the ConfigMap .Validate(request =\u003e { // Validate the ConfigMap has a specific label if (request.HasLabel(\"pepr\")) { return request.Approve(); } // Reject the ConfigMap if it doesn't have the label return request.Deny(\"ConfigMap must have a unicorn label\"); }) // Watch behaves like controller-runtime's Manager.Watch() .Watch(async (cm, phase) =\u003e { Log.info(cm, `ConfigMap was ${phase}.`); // Apply a ConfigMap using K8s server-side apply (will create or update) await K8s(kind.ConfigMap).Apply({ metadata: { name: \"pepr-ssa-demo\", namespace: \"pepr-demo-2\", }, data: { uid: cm.metadata.uid, }, }); }); Prerequisites Node.js v18.0.0+ (even-numbered releases only)\nTo ensure compatability and optimal performance, it is recommended to use even-numbered releases of Node.js as they are stable releases and receive long-term support for three years. Odd-numbered releases are experimental and may not be supported by certain libraries utilized in Pepr. npm v10.1.0+\nRecommended (optional) tools:\nVisual Studio Code for inline debugging and Pepr Capabilities creation. A Kubernetes cluster for npx pepr dev. Pepr modules include npm run k3d-setup if you want to test locally with K3d and Docker. Wow too many words! tl;dr; # Create a new Pepr Module npx pepr init # If you already have a Kind or K3d cluster you want to use, skip this step npm run k3d-setup # Start playing with Pepr now # If using another local K8s distro instead of k3d, run `npx pepr dev --host host.docker.internal` npx pepr dev kubectl apply -f capabilities/hello-pepr.samples.yaml # Be amazed and ⭐️ this repo Concepts Module A module is the top-level collection of capabilities. It is a single, complete TypeScript project that includes an entry point to load all the configuration and capabilities, along with their actions. During the Pepr build process, each module produces a unique Kubernetes MutatingWebhookConfiguration and ValidatingWebhookConfiguration, along with a secret containing the transpiled and compressed TypeScript code. The webhooks and secret are deployed into the Kubernetes cluster with their own isolated controller.\nSee Module for more details.\nCapability A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nSee Capabilities for more details.\nAction Action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in from Kubernetes. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nThere are both Mutate() and Validate() Actions that can be used to modify or validate Kubernetes resources within the admission controller lifecycle. There is also a Watch() Action that can be used to watch for changes to Kubernetes resources that already exist.\nSee actions for more details.\nLogical Pepr Flow Source Diagram\nTypeScript TypeScript is a strongly typed, object-oriented programming language built on top of JavaScript. It provides optional static typing and a rich type system, allowing developers to write more robust code. TypeScript is transpiled to JavaScript, enabling it to run in any environment that supports JavaScript. Pepr allows you to use JavaScript or TypeScript to write capabilities, but TypeScript is recommended for its type safety and rich type system. You can learn more about TypeScript here.\n","categories":"","description":"","excerpt":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission …","ref":"/v0.20.0/","tags":"","title":"v0.20.0"},{"body":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission to save Kubernetes from the tyranny of YAML, intimidating glue code, bash scripts, and other makeshift solutions. As a Kubernetes controller, Pepr empowers you to define Kubernetes transformations using TypeScript, without software development expertise thanks to plain-english configurations. Pepr transforms a patchwork of forks, scripts, overlays, and other chaos into a cohesive, well-structured, and maintainable system. With Pepr, you can seamlessly transition IT ops tribal knowledge into code, simplifying documentation, testing, validation, and coordination of changes for a more predictable outcome.\nNote: Pepr is still in active development so breaking changes may occur, but will be documented in release notes. Features Zero-config K8s webhook mutations and validations Automatic leader-elected K8s resource watching Lightweight async key-value store backed by K8s for stateful operations with the Pepr Store Human-readable fluent API for generating Pepr Capabilities A fluent API for creating/modifying/watching and server-side applying K8s resources via Kubernetes Fluent Client Generate new K8s resources based off of cluster resource changes Perform other exec/API calls based off of cluster resources changes or any other arbitrary schedule Out of the box airgap support with Zarf Entire NPM ecosystem available for advanced operations Realtime K8s debugging system for testing/reacting to cluster changes Controller network isolation and tamper-resistent module execution Least-privilege RBAC generation AMD64 and ARM64 support Example Pepr Action This quick sample shows how to react to a ConfigMap being created or updated in the cluster. It adds a label and annotation to the ConfigMap and adds some data to the ConfigMap. It also creates a Validating Webhook to make sure the “pepr” label still exists. Finally, after the ConfigMap is created, it logs a message to the Pepr controller and creates or updates a separate ConfigMap with the kubernetes-fluent-client using server-side apply. For more details see actions section.\nWhen(a.ConfigMap) .IsCreatedOrUpdated() .InNamespace(\"pepr-demo\") .WithLabel(\"unicorn\", \"rainbow\") // Create a Mutate Action for the ConfigMap .Mutate(request =\u003e { // Add a label and annotation to the ConfigMap request.SetLabel(\"pepr\", \"was-here\").SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Add some data to the ConfigMap request.Raw.data[\"doug-says\"] = \"Pepr is awesome!\"; // Log a message to the Pepr controller logs Log.info(\"A 🦄 ConfigMap was created or updated:\"); }) // Create a Validate Action for the ConfigMap .Validate(request =\u003e { // Validate the ConfigMap has a specific label if (request.HasLabel(\"pepr\")) { return request.Approve(); } // Reject the ConfigMap if it doesn't have the label return request.Deny(\"ConfigMap must have a unicorn label\"); }) // Watch behaves like controller-runtime's Manager.Watch() .Watch(async (cm, phase) =\u003e { Log.info(cm, `ConfigMap was ${phase}.`); // Apply a ConfigMap using K8s server-side apply (will create or update) await K8s(kind.ConfigMap).Apply({ metadata: { name: \"pepr-ssa-demo\", namespace: \"pepr-demo-2\", }, data: { uid: cm.metadata.uid, }, }); }); Prerequisites Node.js v18.0.0+ (even-numbered releases only)\nTo ensure compatability and optimal performance, it is recommended to use even-numbered releases of Node.js as they are stable releases and receive long-term support for three years. Odd-numbered releases are experimental and may not be supported by certain libraries utilized in Pepr. npm v10.1.0+\nRecommended (optional) tools:\nVisual Studio Code for inline debugging and Pepr Capabilities creation. A Kubernetes cluster for npx pepr dev. Pepr modules include npm run k3d-setup if you want to test locally with K3d and Docker. Wow too many words! tl;dr; # Create a new Pepr Module npx pepr init # If you already have a Kind or K3d cluster you want to use, skip this step npm run k3d-setup # Start playing with Pepr now # If using another local K8s distro instead of k3d, run `npx pepr dev --host host.docker.internal` npx pepr dev kubectl apply -f capabilities/hello-pepr.samples.yaml # Be amazed and ⭐️ this repo Concepts Module A module is the top-level collection of capabilities. It is a single, complete TypeScript project that includes an entry point to load all the configuration and capabilities, along with their actions. During the Pepr build process, each module produces a unique Kubernetes MutatingWebhookConfiguration and ValidatingWebhookConfiguration, along with a secret containing the transpiled and compressed TypeScript code. The webhooks and secret are deployed into the Kubernetes cluster with their own isolated controller.\nSee Module for more details.\nCapability A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nSee Capabilities for more details.\nAction Action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in from Kubernetes. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nThere are both Mutate() and Validate() Actions that can be used to modify or validate Kubernetes resources within the admission controller lifecycle. There is also a Watch() Action that can be used to watch for changes to Kubernetes resources that already exist.\nSee actions for more details.\nLogical Pepr Flow Source Diagram\nTypeScript TypeScript is a strongly typed, object-oriented programming language built on top of JavaScript. It provides optional static typing and a rich type system, allowing developers to write more robust code. TypeScript is transpiled to JavaScript, enabling it to run in any environment that supports JavaScript. Pepr allows you to use JavaScript or TypeScript to write capabilities, but TypeScript is recommended for its type safety and rich type system. You can learn more about TypeScript here.\n","categories":"","description":"","excerpt":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission …","ref":"/v0.20.1/","tags":"","title":"v0.20.1"},{"body":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission to save Kubernetes from the tyranny of YAML, intimidating glue code, bash scripts, and other makeshift solutions. As a Kubernetes controller, Pepr empowers you to define Kubernetes transformations using TypeScript, without software development expertise thanks to plain-english configurations. Pepr transforms a patchwork of forks, scripts, overlays, and other chaos into a cohesive, well-structured, and maintainable system. With Pepr, you can seamlessly transition IT ops tribal knowledge into code, simplifying documentation, testing, validation, and coordination of changes for a more predictable outcome.\nNote: Pepr is still in active development so breaking changes may occur, but will be documented in release notes. Features Zero-config K8s webhook mutations and validations Automatic leader-elected K8s resource watching Lightweight async key-value store backed by K8s for stateful operations with the Pepr Store Human-readable fluent API for generating Pepr Capabilities A fluent API for creating/modifying/watching and server-side applying K8s resources via Kubernetes Fluent Client Generate new K8s resources based off of cluster resource changes Perform other exec/API calls based off of cluster resources changes or any other arbitrary schedule Out of the box airgap support with Zarf Entire NPM ecosystem available for advanced operations Realtime K8s debugging system for testing/reacting to cluster changes Controller network isolation and tamper-resistent module execution Least-privilege RBAC generation AMD64 and ARM64 support Example Pepr Action This quick sample shows how to react to a ConfigMap being created or updated in the cluster. It adds a label and annotation to the ConfigMap and adds some data to the ConfigMap. It also creates a Validating Webhook to make sure the “pepr” label still exists. Finally, after the ConfigMap is created, it logs a message to the Pepr controller and creates or updates a separate ConfigMap with the kubernetes-fluent-client using server-side apply. For more details see actions section.\nWhen(a.ConfigMap) .IsCreatedOrUpdated() .InNamespace(\"pepr-demo\") .WithLabel(\"unicorn\", \"rainbow\") // Create a Mutate Action for the ConfigMap .Mutate(request =\u003e { // Add a label and annotation to the ConfigMap request.SetLabel(\"pepr\", \"was-here\").SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Add some data to the ConfigMap request.Raw.data[\"doug-says\"] = \"Pepr is awesome!\"; // Log a message to the Pepr controller logs Log.info(\"A 🦄 ConfigMap was created or updated:\"); }) // Create a Validate Action for the ConfigMap .Validate(request =\u003e { // Validate the ConfigMap has a specific label if (request.HasLabel(\"pepr\")) { return request.Approve(); } // Reject the ConfigMap if it doesn't have the label return request.Deny(\"ConfigMap must have a unicorn label\"); }) // Watch behaves like controller-runtime's Manager.Watch() .Watch(async (cm, phase) =\u003e { Log.info(cm, `ConfigMap was ${phase}.`); // Apply a ConfigMap using K8s server-side apply (will create or update) await K8s(kind.ConfigMap).Apply({ metadata: { name: \"pepr-ssa-demo\", namespace: \"pepr-demo-2\", }, data: { uid: cm.metadata.uid, }, }); }); Prerequisites Node.js v18.0.0+ (even-numbered releases only)\nTo ensure compatability and optimal performance, it is recommended to use even-numbered releases of Node.js as they are stable releases and receive long-term support for three years. Odd-numbered releases are experimental and may not be supported by certain libraries utilized in Pepr. npm v10.1.0+\nRecommended (optional) tools:\nVisual Studio Code for inline debugging and Pepr Capabilities creation. A Kubernetes cluster for npx pepr dev. Pepr modules include npm run k3d-setup if you want to test locally with K3d and Docker. Wow too many words! tl;dr; # Create a new Pepr Module npx pepr init # If you already have a Kind or K3d cluster you want to use, skip this step npm run k3d-setup # Start playing with Pepr now # If using another local K8s distro instead of k3d, run `npx pepr dev --host host.docker.internal` npx pepr dev kubectl apply -f capabilities/hello-pepr.samples.yaml # Be amazed and ⭐️ this repo Concepts Module A module is the top-level collection of capabilities. It is a single, complete TypeScript project that includes an entry point to load all the configuration and capabilities, along with their actions. During the Pepr build process, each module produces a unique Kubernetes MutatingWebhookConfiguration and ValidatingWebhookConfiguration, along with a secret containing the transpiled and compressed TypeScript code. The webhooks and secret are deployed into the Kubernetes cluster with their own isolated controller.\nSee Module for more details.\nCapability A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nSee Capabilities for more details.\nAction Action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in from Kubernetes. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nThere are both Mutate() and Validate() Actions that can be used to modify or validate Kubernetes resources within the admission controller lifecycle. There is also a Watch() Action that can be used to watch for changes to Kubernetes resources that already exist.\nSee actions for more details.\nLogical Pepr Flow Source Diagram\nTypeScript TypeScript is a strongly typed, object-oriented programming language built on top of JavaScript. It provides optional static typing and a rich type system, allowing developers to write more robust code. TypeScript is transpiled to JavaScript, enabling it to run in any environment that supports JavaScript. Pepr allows you to use JavaScript or TypeScript to write capabilities, but TypeScript is recommended for its type safety and rich type system. You can learn more about TypeScript here.\n","categories":"","description":"","excerpt":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission …","ref":"/v0.20.2/","tags":"","title":"v0.20.2"},{"body":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission to save Kubernetes from the tyranny of YAML, intimidating glue code, bash scripts, and other makeshift solutions. As a Kubernetes controller, Pepr empowers you to define Kubernetes transformations using TypeScript, without software development expertise thanks to plain-english configurations. Pepr transforms a patchwork of forks, scripts, overlays, and other chaos into a cohesive, well-structured, and maintainable system. With Pepr, you can seamlessly transition IT ops tribal knowledge into code, simplifying documentation, testing, validation, and coordination of changes for a more predictable outcome.\nNote: Pepr is still in active development so breaking changes may occur, but will be documented in release notes. Features Zero-config K8s webhook mutations and validations Automatic leader-elected K8s resource watching Lightweight async key-value store backed by K8s for stateful operations with the Pepr Store Human-readable fluent API for generating Pepr Capabilities A fluent API for creating/modifying/watching and server-side applying K8s resources via Kubernetes Fluent Client Generate new K8s resources based off of cluster resource changes Perform other exec/API calls based off of cluster resources changes or any other arbitrary schedule Out of the box airgap support with Zarf Entire NPM ecosystem available for advanced operations Realtime K8s debugging system for testing/reacting to cluster changes Controller network isolation and tamper-resistent module execution Least-privilege RBAC generation AMD64 and ARM64 support Example Pepr Action This quick sample shows how to react to a ConfigMap being created or updated in the cluster. It adds a label and annotation to the ConfigMap and adds some data to the ConfigMap. It also creates a Validating Webhook to make sure the “pepr” label still exists. Finally, after the ConfigMap is created, it logs a message to the Pepr controller and creates or updates a separate ConfigMap with the kubernetes-fluent-client using server-side apply. For more details see actions section.\nWhen(a.ConfigMap) .IsCreatedOrUpdated() .InNamespace(\"pepr-demo\") .WithLabel(\"unicorn\", \"rainbow\") // Create a Mutate Action for the ConfigMap .Mutate(request =\u003e { // Add a label and annotation to the ConfigMap request.SetLabel(\"pepr\", \"was-here\").SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Add some data to the ConfigMap request.Raw.data[\"doug-says\"] = \"Pepr is awesome!\"; // Log a message to the Pepr controller logs Log.info(\"A 🦄 ConfigMap was created or updated:\"); }) // Create a Validate Action for the ConfigMap .Validate(request =\u003e { // Validate the ConfigMap has a specific label if (request.HasLabel(\"pepr\")) { return request.Approve(); } // Reject the ConfigMap if it doesn't have the label return request.Deny(\"ConfigMap must have a unicorn label\"); }) // Watch behaves like controller-runtime's Manager.Watch() .Watch(async (cm, phase) =\u003e { Log.info(cm, `ConfigMap was ${phase}.`); // Apply a ConfigMap using K8s server-side apply (will create or update) await K8s(kind.ConfigMap).Apply({ metadata: { name: \"pepr-ssa-demo\", namespace: \"pepr-demo-2\", }, data: { uid: cm.metadata.uid, }, }); }); Prerequisites Node.js v18.0.0+ (even-numbered releases only)\nTo ensure compatability and optimal performance, it is recommended to use even-numbered releases of Node.js as they are stable releases and receive long-term support for three years. Odd-numbered releases are experimental and may not be supported by certain libraries utilized in Pepr. npm v10.1.0+\nRecommended (optional) tools:\nVisual Studio Code for inline debugging and Pepr Capabilities creation. A Kubernetes cluster for npx pepr dev. Pepr modules include npm run k3d-setup if you want to test locally with K3d and Docker. Wow too many words! tl;dr; # Create a new Pepr Module npx pepr init # If you already have a Kind or K3d cluster you want to use, skip this step npm run k3d-setup # Start playing with Pepr now # If using another local K8s distro instead of k3d, run `npx pepr dev --host host.docker.internal` npx pepr dev kubectl apply -f capabilities/hello-pepr.samples.yaml # Be amazed and ⭐️ this repo Concepts Module A module is the top-level collection of capabilities. It is a single, complete TypeScript project that includes an entry point to load all the configuration and capabilities, along with their actions. During the Pepr build process, each module produces a unique Kubernetes MutatingWebhookConfiguration and ValidatingWebhookConfiguration, along with a secret containing the transpiled and compressed TypeScript code. The webhooks and secret are deployed into the Kubernetes cluster with their own isolated controller.\nSee Module for more details.\nCapability A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nSee Capabilities for more details.\nAction Action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in from Kubernetes. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nThere are both Mutate() and Validate() Actions that can be used to modify or validate Kubernetes resources within the admission controller lifecycle. There is also a Watch() Action that can be used to watch for changes to Kubernetes resources that already exist.\nSee actions for more details.\nLogical Pepr Flow Source Diagram\nTypeScript TypeScript is a strongly typed, object-oriented programming language built on top of JavaScript. It provides optional static typing and a rich type system, allowing developers to write more robust code. TypeScript is transpiled to JavaScript, enabling it to run in any environment that supports JavaScript. Pepr allows you to use JavaScript or TypeScript to write capabilities, but TypeScript is recommended for its type safety and rich type system. You can learn more about TypeScript here.\n","categories":"","description":"","excerpt":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission …","ref":"/v0.20.3/","tags":"","title":"v0.20.3"},{"body":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission to save Kubernetes from the tyranny of YAML, intimidating glue code, bash scripts, and other makeshift solutions. As a Kubernetes controller, Pepr empowers you to define Kubernetes transformations using TypeScript, without software development expertise thanks to plain-english configurations. Pepr transforms a patchwork of forks, scripts, overlays, and other chaos into a cohesive, well-structured, and maintainable system. With Pepr, you can seamlessly transition IT ops tribal knowledge into code, simplifying documentation, testing, validation, and coordination of changes for a more predictable outcome.\nNote: Pepr is still in active development so breaking changes may occur, but will be documented in release notes. Features Zero-config K8s webhook mutations and validations Automatic leader-elected K8s resource watching Lightweight async key-value store backed by K8s for stateful operations with the Pepr Store Human-readable fluent API for generating Pepr Capabilities A fluent API for creating/modifying/watching and server-side applying K8s resources via Kubernetes Fluent Client Generate new K8s resources based off of cluster resource changes Perform other exec/API calls based off of cluster resources changes or any other arbitrary schedule Out of the box airgap support with Zarf Entire NPM ecosystem available for advanced operations Realtime K8s debugging system for testing/reacting to cluster changes Controller network isolation and tamper-resistent module execution Least-privilege RBAC generation AMD64 and ARM64 support Example Pepr Action This quick sample shows how to react to a ConfigMap being created or updated in the cluster. It adds a label and annotation to the ConfigMap and adds some data to the ConfigMap. It also creates a Validating Webhook to make sure the “pepr” label still exists. Finally, after the ConfigMap is created, it logs a message to the Pepr controller and creates or updates a separate ConfigMap with the kubernetes-fluent-client using server-side apply. For more details see actions section.\nWhen(a.ConfigMap) .IsCreatedOrUpdated() .InNamespace(\"pepr-demo\") .WithLabel(\"unicorn\", \"rainbow\") // Create a Mutate Action for the ConfigMap .Mutate(request =\u003e { // Add a label and annotation to the ConfigMap request.SetLabel(\"pepr\", \"was-here\").SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Add some data to the ConfigMap request.Raw.data[\"doug-says\"] = \"Pepr is awesome!\"; // Log a message to the Pepr controller logs Log.info(\"A 🦄 ConfigMap was created or updated:\"); }) // Create a Validate Action for the ConfigMap .Validate(request =\u003e { // Validate the ConfigMap has a specific label if (request.HasLabel(\"pepr\")) { return request.Approve(); } // Reject the ConfigMap if it doesn't have the label return request.Deny(\"ConfigMap must have a unicorn label\"); }) // Watch behaves like controller-runtime's Manager.Watch() .Watch(async (cm, phase) =\u003e { Log.info(cm, `ConfigMap was ${phase}.`); // Apply a ConfigMap using K8s server-side apply (will create or update) await K8s(kind.ConfigMap).Apply({ metadata: { name: \"pepr-ssa-demo\", namespace: \"pepr-demo-2\", }, data: { uid: cm.metadata.uid, }, }); }); Prerequisites Node.js v18.0.0+ (even-numbered releases only)\nTo ensure compatability and optimal performance, it is recommended to use even-numbered releases of Node.js as they are stable releases and receive long-term support for three years. Odd-numbered releases are experimental and may not be supported by certain libraries utilized in Pepr. npm v10.1.0+\nRecommended (optional) tools:\nVisual Studio Code for inline debugging and Pepr Capabilities creation. A Kubernetes cluster for npx pepr dev. Pepr modules include npm run k3d-setup if you want to test locally with K3d and Docker. Wow too many words! tl;dr; # Create a new Pepr Module npx pepr init # If you already have a Kind or K3d cluster you want to use, skip this step npm run k3d-setup # Start playing with Pepr now # If using another local K8s distro instead of k3d, run `npx pepr dev --host host.docker.internal` npx pepr dev kubectl apply -f capabilities/hello-pepr.samples.yaml # Be amazed and ⭐️ this repo Concepts Module A module is the top-level collection of capabilities. It is a single, complete TypeScript project that includes an entry point to load all the configuration and capabilities, along with their actions. During the Pepr build process, each module produces a unique Kubernetes MutatingWebhookConfiguration and ValidatingWebhookConfiguration, along with a secret containing the transpiled and compressed TypeScript code. The webhooks and secret are deployed into the Kubernetes cluster with their own isolated controller.\nSee Module for more details.\nCapability A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nSee Capabilities for more details.\nAction Action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in from Kubernetes. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nThere are both Mutate() and Validate() Actions that can be used to modify or validate Kubernetes resources within the admission controller lifecycle. There is also a Watch() Action that can be used to watch for changes to Kubernetes resources that already exist.\nSee actions for more details.\nLogical Pepr Flow Source Diagram\nTypeScript TypeScript is a strongly typed, object-oriented programming language built on top of JavaScript. It provides optional static typing and a rich type system, allowing developers to write more robust code. TypeScript is transpiled to JavaScript, enabling it to run in any environment that supports JavaScript. Pepr allows you to use JavaScript or TypeScript to write capabilities, but TypeScript is recommended for its type safety and rich type system. You can learn more about TypeScript here.\n","categories":"","description":"","excerpt":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission …","ref":"/v0.21.0/","tags":"","title":"v0.21.0"},{"body":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission to save Kubernetes from the tyranny of YAML, intimidating glue code, bash scripts, and other makeshift solutions. As a Kubernetes controller, Pepr empowers you to define Kubernetes transformations using TypeScript, without software development expertise thanks to plain-english configurations. Pepr transforms a patchwork of forks, scripts, overlays, and other chaos into a cohesive, well-structured, and maintainable system. With Pepr, you can seamlessly transition IT ops tribal knowledge into code, simplifying documentation, testing, validation, and coordination of changes for a more predictable outcome.\nNote: Pepr is still in active development so breaking changes may occur, but will be documented in release notes. Features Zero-config K8s webhook mutations and validations Automatic leader-elected K8s resource watching Lightweight async key-value store backed by K8s for stateful operations with the Pepr Store Human-readable fluent API for generating Pepr Capabilities A fluent API for creating/modifying/watching and server-side applying K8s resources via Kubernetes Fluent Client Generate new K8s resources based off of cluster resource changes Perform other exec/API calls based off of cluster resources changes or any other arbitrary schedule Out of the box airgap support with Zarf Entire NPM ecosystem available for advanced operations Realtime K8s debugging system for testing/reacting to cluster changes Controller network isolation and tamper-resistent module execution Least-privilege RBAC generation AMD64 and ARM64 support Example Pepr Action This quick sample shows how to react to a ConfigMap being created or updated in the cluster. It adds a label and annotation to the ConfigMap and adds some data to the ConfigMap. It also creates a Validating Webhook to make sure the “pepr” label still exists. Finally, after the ConfigMap is created, it logs a message to the Pepr controller and creates or updates a separate ConfigMap with the kubernetes-fluent-client using server-side apply. For more details see actions section.\nWhen(a.ConfigMap) .IsCreatedOrUpdated() .InNamespace(\"pepr-demo\") .WithLabel(\"unicorn\", \"rainbow\") // Create a Mutate Action for the ConfigMap .Mutate(request =\u003e { // Add a label and annotation to the ConfigMap request.SetLabel(\"pepr\", \"was-here\").SetAnnotation(\"pepr.dev\", \"annotations-work-too\"); // Add some data to the ConfigMap request.Raw.data[\"doug-says\"] = \"Pepr is awesome!\"; // Log a message to the Pepr controller logs Log.info(\"A 🦄 ConfigMap was created or updated:\"); }) // Create a Validate Action for the ConfigMap .Validate(request =\u003e { // Validate the ConfigMap has a specific label if (request.HasLabel(\"pepr\")) { return request.Approve(); } // Reject the ConfigMap if it doesn't have the label return request.Deny(\"ConfigMap must have a unicorn label\"); }) // Watch behaves like controller-runtime's Manager.Watch() .Watch(async (cm, phase) =\u003e { Log.info(cm, `ConfigMap was ${phase}.`); // Apply a ConfigMap using K8s server-side apply (will create or update) await K8s(kind.ConfigMap).Apply({ metadata: { name: \"pepr-ssa-demo\", namespace: \"pepr-demo-2\", }, data: { uid: cm.metadata.uid, }, }); }); Prerequisites Node.js v18.0.0+ (even-numbered releases only)\nTo ensure compatability and optimal performance, it is recommended to use even-numbered releases of Node.js as they are stable releases and receive long-term support for three years. Odd-numbered releases are experimental and may not be supported by certain libraries utilized in Pepr. npm v10.1.0+\nRecommended (optional) tools:\nVisual Studio Code for inline debugging and Pepr Capabilities creation. A Kubernetes cluster for npx pepr dev. Pepr modules include npm run k3d-setup if you want to test locally with K3d and Docker. Wow too many words! tl;dr; # Create a new Pepr Module npx pepr init # If you already have a Kind or K3d cluster you want to use, skip this step npm run k3d-setup # Start playing with Pepr now # If using another local K8s distro instead of k3d, run `npx pepr dev --host host.docker.internal` npx pepr dev kubectl apply -f capabilities/hello-pepr.samples.yaml # Be amazed and ⭐️ this repo Concepts Module A module is the top-level collection of capabilities. It is a single, complete TypeScript project that includes an entry point to load all the configuration and capabilities, along with their actions. During the Pepr build process, each module produces a unique Kubernetes MutatingWebhookConfiguration and ValidatingWebhookConfiguration, along with a secret containing the transpiled and compressed TypeScript code. The webhooks and secret are deployed into the Kubernetes cluster with their own isolated controller.\nSee Module for more details.\nCapability A capability is set of related actions that work together to achieve a specific transformation or operation on Kubernetes resources. Capabilities are user-defined and can include one or more actions. They are defined within a Pepr module and can be used in both MutatingWebhookConfigurations and ValidatingWebhookConfigurations. A Capability can have a specific scope, such as mutating or validating, and can be reused in multiple Pepr modules.\nSee Capabilities for more details.\nAction Action is a discrete set of behaviors defined in a single function that acts on a given Kubernetes GroupVersionKind (GVK) passed in from Kubernetes. Actions are the atomic operations that are performed on Kubernetes resources by Pepr.\nFor example, an action could be responsible for adding a specific label to a Kubernetes resource, or for modifying a specific field in a resource’s metadata. Actions can be grouped together within a Capability to provide a more comprehensive set of operations that can be performed on Kubernetes resources.\nThere are both Mutate() and Validate() Actions that can be used to modify or validate Kubernetes resources within the admission controller lifecycle. There is also a Watch() Action that can be used to watch for changes to Kubernetes resources that already exist.\nSee actions for more details.\nLogical Pepr Flow Source Diagram\nTypeScript TypeScript is a strongly typed, object-oriented programming language built on top of JavaScript. It provides optional static typing and a rich type system, allowing developers to write more robust code. TypeScript is transpiled to JavaScript, enabling it to run in any environment that supports JavaScript. Pepr allows you to use JavaScript or TypeScript to write capabilities, but TypeScript is recommended for its type safety and rich type system. You can learn more about TypeScript here.\n","categories":"","description":"","excerpt":"Pepr Type safe Kubernetes middleware for humans Pepr is on a mission …","ref":"/v0.21.1/","tags":"","title":"v0.21.1"},{"body":"Pepr fully supports WebAssembly. Depending on the language used to generate the WASM, certain files can be too large to fit into a Secret or ConfigMap. Due to this limitation, users have the ability to incorporate *.wasm and any other essential files during the build phase, which are then embedded into the Pepr Controller container. This is achieved through adding an array of files to the includedFiles section under pepr in the package.json.\nNOTE - In order to instantiate the WebAsembly module in TypeScript, you need the WebAssembly type. This is accomplished through add the “DOM” to the lib array in the compilerOptions section of the tsconfig.json. Ex: \"lib\": [\"ES2022\", \"DOM\"]. Be aware that adding the DOM will add a lot of extra types to your project and your developer experience will be impacted in terms of the intellisense.\nHigh-Level Overview WASM support is achieved through adding files as layers atop the Pepr controller image, these files are then able to be read by the individual capabilities. The key components of WASM support are:\nAdd files to the base of the Pepr module. Reference the files in the includedFiles section of the pepr block of the package.json Run npx pepr build with the -r option specifying registry info. Ex: npx pepr build -r docker.io/cmwylie19 Pepr builds and pushes a custom image that is used in the Deployment. Using WASM Support Creating a WASM Module in Go Create a simple Go function that you want to call from your Pepr module\npackage main import ( \"fmt\" \"syscall/js\" ) func concats(this js.Value, args []js.Value) interface{} { fmt.Println(\"PeprWASM!\") stringOne := args[0].String() stringTwo := args[1].String() return fmt.Sprintf(\"%s%s\", stringOne, stringTwo) } func main() { done := make(chan struct{}, 0) js.Global().Set(\"concats\", js.FuncOf(concats)) \u003c-done } Compile it to a wasm target and move it to your Pepr module\nGOOS=js GOARCH=wasm go build -o main.wasm cp main.wasm $YOUR_PEPR_MODULE/ Copy the wasm_exec.js from GOROOT to your Pepr Module\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" $YOUR_PEPR_MODULE/ Update the polyfill to add globalThis.crypto in the wasm_exec.js since we are not running in the browser. This is needed directly under: (() =\u003e {\n// Initialize the polyfill if (typeof globalThis.crypto === 'undefined') { globalThis.crypto = { getRandomValues: (array) =\u003e { for (let i = 0; i \u003c array.length; i++) { array[i] = Math.floor(Math.random() * 256); } }, }; } Configure Pepr to use WASM After adding the files to the root of the Pepr module, reference those files in the package.json:\n{ \"name\": \"pepr-test-module\", \"version\": \"0.0.1\", \"description\": \"A test module for Pepr\", \"keywords\": [ \"pepr\", \"k8s\", \"policy-engine\", \"pepr-module\", \"security\" ], \"engines\": { \"node\": \"\u003e=18.0.0\" }, \"pepr\": { \"name\": \"pepr-test-module\", \"uuid\": \"static-test\", \"onError\": \"ignore\", \"alwaysIgnore\": { \"namespaces\": [], \"labels\": [] }, \"includedFiles\":[ \"main.wasm\", \"wasm_exec.js\" ] }, ... } Update the tsconfig.json to add “DOM” to the compilerOptions lib:\n{ \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, \"declaration\": true, \"declarationMap\": true, \"emitDeclarationOnly\": true, \"esModuleInterop\": true, \"lib\": [ \"ES2022\", \"DOM\" // \u003c- Add this ], \"module\": \"CommonJS\", \"moduleResolution\": \"node\", \"outDir\": \"dist\", \"resolveJsonModule\": true, \"rootDir\": \".\", \"strict\": false, \"target\": \"ES2022\", \"useUnknownInCatchVariables\": false }, \"include\": [ \"**/*.ts\" ] } Call WASM functions from TypeScript Import the wasm_exec.js in the pepr.ts\nimport \"./wasm_exec.js\"; Create a helper function to load the wasm file in a capability and call it during an event of your choice\nasync function callWASM(a,b) { const go = new globalThis.Go(); const wasmData = readFileSync(\"main.wasm\"); var concated: string; await WebAssembly.instantiate(wasmData, go.importObject).then(wasmModule =\u003e { go.run(wasmModule.instance); concated = global.concats(a,b); }); return concated; } When(a.Pod) .IsCreated() .Mutate(async pod =\u003e { try { let label_value = await callWASM(\"loves\",\"wasm\") pod.SetLabel(\"pepr\",label_value) } catch(err) { Log.error(err); } }); Run Pepr Build Build your Pepr module with the registry specified.\nnpx pepr build -r docker.io/defenseunicorns ","categories":"","description":"","excerpt":"Pepr fully supports WebAssembly. Depending on the language used to …","ref":"/main/webassembly/","tags":"","title":"WASM Support Running WebAssembly in Pepr Guide"},{"body":"Pepr fully supports WebAssembly. Depending on the language used to generate the WASM, certain files can be too large to fit into a Secret or ConfigMap. Due to this limitation, users have the ability to incorporate *.wasm and any other essential files during the build phase, which are then embedded into the Pepr Controller container. This is achieved through adding an array of files to the includedFiles section under pepr in the package.json.\nNOTE - In order to instantiate the WebAsembly module in TypeScript, you need the WebAssembly type. This is accomplished through add the “DOM” to the lib array in the compilerOptions section of the tsconfig.json. Ex: \"lib\": [\"ES2022\", \"DOM\"]. Be aware that adding the DOM will add a lot of extra types to your project and your developer experience will be impacted in terms of the intellisense.\nHigh-Level Overview WASM support is achieved through adding files as layers atop the Pepr controller image, these files are then able to be read by the individual capabilities. The key components of WASM support are:\nAdd files to the base of the Pepr module. Reference the files in the includedFiles section of the pepr block of the package.json Run npx pepr build with the -r option specifying registry info. Ex: npx pepr build -r docker.io/cmwylie19 Pepr builds and pushes a custom image that is used in the Deployment. Using WASM Support Creating a WASM Module in Go Create a simple Go function that you want to call from your Pepr module\npackage main import ( \"fmt\" \"syscall/js\" ) func concats(this js.Value, args []js.Value) interface{} { fmt.Println(\"PeprWASM!\") stringOne := args[0].String() stringTwo := args[1].String() return fmt.Sprintf(\"%s%s\", stringOne, stringTwo) } func main() { done := make(chan struct{}, 0) js.Global().Set(\"concats\", js.FuncOf(concats)) \u003c-done } Compile it to a wasm target and move it to your Pepr module\nGOOS=js GOARCH=wasm go build -o main.wasm cp main.wasm $YOUR_PEPR_MODULE/ Copy the wasm_exec.js from GOROOT to your Pepr Module\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" $YOUR_PEPR_MODULE/ Update the polyfill to add globalThis.crypto in the wasm_exec.js since we are not running in the browser. This is needed directly under: (() =\u003e {\n// Initialize the polyfill if (typeof globalThis.crypto === 'undefined') { globalThis.crypto = { getRandomValues: (array) =\u003e { for (let i = 0; i \u003c array.length; i++) { array[i] = Math.floor(Math.random() * 256); } }, }; } Configure Pepr to use WASM After adding the files to the root of the Pepr module, reference those files in the package.json:\n{ \"name\": \"pepr-test-module\", \"version\": \"0.0.1\", \"description\": \"A test module for Pepr\", \"keywords\": [ \"pepr\", \"k8s\", \"policy-engine\", \"pepr-module\", \"security\" ], \"engines\": { \"node\": \"\u003e=18.0.0\" }, \"pepr\": { \"name\": \"pepr-test-module\", \"uuid\": \"static-test\", \"onError\": \"ignore\", \"alwaysIgnore\": { \"namespaces\": [], \"labels\": [] }, \"includedFiles\":[ \"main.wasm\", \"wasm_exec.js\" ] }, ... } Update the tsconfig.json to add “DOM” to the compilerOptions lib:\n{ \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, \"declaration\": true, \"declarationMap\": true, \"emitDeclarationOnly\": true, \"esModuleInterop\": true, \"lib\": [ \"ES2022\", \"DOM\" // \u003c- Add this ], \"module\": \"CommonJS\", \"moduleResolution\": \"node\", \"outDir\": \"dist\", \"resolveJsonModule\": true, \"rootDir\": \".\", \"strict\": false, \"target\": \"ES2022\", \"useUnknownInCatchVariables\": false }, \"include\": [ \"**/*.ts\" ] } Call WASM functions from TypeScript Import the wasm_exec.js in the pepr.ts\nimport \"./wasm_exec.js\"; Create a helper function to load the wasm file in a capability and call it during an event of your choice\nasync function callWASM(a,b) { const go = new globalThis.Go(); const wasmData = readFileSync(\"main.wasm\"); var concated: string; await WebAssembly.instantiate(wasmData, go.importObject).then(wasmModule =\u003e { go.run(wasmModule.instance); concated = global.concats(a,b); }); return concated; } When(a.Pod) .IsCreated() .Mutate(async pod =\u003e { try { let label_value = await callWASM(\"loves\",\"wasm\") pod.SetLabel(\"pepr\",label_value) } catch(err) { Log.error(err); } }); Run Pepr Build Build your Pepr module with the registry specified.\nnpx pepr build -r docker.io/defenseunicorns ","categories":"","description":"","excerpt":"Pepr fully supports WebAssembly. Depending on the language used to …","ref":"/v0.19.0/webassembly/","tags":"","title":"WASM Support Running WebAssembly in Pepr Guide"},{"body":"Pepr fully supports WebAssembly. Depending on the language used to generate the WASM, certain files can be too large to fit into a Secret or ConfigMap. Due to this limitation, users have the ability to incorporate *.wasm and any other essential files during the build phase, which are then embedded into the Pepr Controller container. This is achieved through adding an array of files to the includedFiles section under pepr in the package.json.\nNOTE - In order to instantiate the WebAsembly module in TypeScript, you need the WebAssembly type. This is accomplished through add the “DOM” to the lib array in the compilerOptions section of the tsconfig.json. Ex: \"lib\": [\"ES2022\", \"DOM\"]. Be aware that adding the DOM will add a lot of extra types to your project and your developer experience will be impacted in terms of the intellisense.\nHigh-Level Overview WASM support is achieved through adding files as layers atop the Pepr controller image, these files are then able to be read by the individual capabilities. The key components of WASM support are:\nAdd files to the base of the Pepr module. Reference the files in the includedFiles section of the pepr block of the package.json Run npx pepr build with the -r option specifying registry info. Ex: npx pepr build -r docker.io/cmwylie19 Pepr builds and pushes a custom image that is used in the Deployment. Using WASM Support Creating a WASM Module in Go Create a simple Go function that you want to call from your Pepr module\npackage main import ( \"fmt\" \"syscall/js\" ) func concats(this js.Value, args []js.Value) interface{} { fmt.Println(\"PeprWASM!\") stringOne := args[0].String() stringTwo := args[1].String() return fmt.Sprintf(\"%s%s\", stringOne, stringTwo) } func main() { done := make(chan struct{}, 0) js.Global().Set(\"concats\", js.FuncOf(concats)) \u003c-done } Compile it to a wasm target and move it to your Pepr module\nGOOS=js GOARCH=wasm go build -o main.wasm cp main.wasm $YOUR_PEPR_MODULE/ Copy the wasm_exec.js from GOROOT to your Pepr Module\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" $YOUR_PEPR_MODULE/ Update the polyfill to add globalThis.crypto in the wasm_exec.js since we are not running in the browser. This is needed directly under: (() =\u003e {\n// Initialize the polyfill if (typeof globalThis.crypto === 'undefined') { globalThis.crypto = { getRandomValues: (array) =\u003e { for (let i = 0; i \u003c array.length; i++) { array[i] = Math.floor(Math.random() * 256); } }, }; } Configure Pepr to use WASM After adding the files to the root of the Pepr module, reference those files in the package.json:\n{ \"name\": \"pepr-test-module\", \"version\": \"0.0.1\", \"description\": \"A test module for Pepr\", \"keywords\": [ \"pepr\", \"k8s\", \"policy-engine\", \"pepr-module\", \"security\" ], \"engines\": { \"node\": \"\u003e=18.0.0\" }, \"pepr\": { \"name\": \"pepr-test-module\", \"uuid\": \"static-test\", \"onError\": \"ignore\", \"alwaysIgnore\": { \"namespaces\": [], \"labels\": [] }, \"includedFiles\":[ \"main.wasm\", \"wasm_exec.js\" ] }, ... } Update the tsconfig.json to add “DOM” to the compilerOptions lib:\n{ \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, \"declaration\": true, \"declarationMap\": true, \"emitDeclarationOnly\": true, \"esModuleInterop\": true, \"lib\": [ \"ES2022\", \"DOM\" // \u003c- Add this ], \"module\": \"CommonJS\", \"moduleResolution\": \"node\", \"outDir\": \"dist\", \"resolveJsonModule\": true, \"rootDir\": \".\", \"strict\": false, \"target\": \"ES2022\", \"useUnknownInCatchVariables\": false }, \"include\": [ \"**/*.ts\" ] } Call WASM functions from TypeScript Import the wasm_exec.js in the pepr.ts\nimport \"./wasm_exec.js\"; Create a helper function to load the wasm file in a capability and call it during an event of your choice\nasync function callWASM(a,b) { const go = new globalThis.Go(); const wasmData = readFileSync(\"main.wasm\"); var concated: string; await WebAssembly.instantiate(wasmData, go.importObject).then(wasmModule =\u003e { go.run(wasmModule.instance); concated = global.concats(a,b); }); return concated; } When(a.Pod) .IsCreated() .Mutate(async pod =\u003e { try { let label_value = await callWASM(\"loves\",\"wasm\") pod.SetLabel(\"pepr\",label_value) } catch(err) { Log.error(err); } }); Run Pepr Build Build your Pepr module with the registry specified.\nnpx pepr build -r docker.io/defenseunicorns ","categories":"","description":"","excerpt":"Pepr fully supports WebAssembly. Depending on the language used to …","ref":"/v0.20.0/webassembly/","tags":"","title":"WASM Support Running WebAssembly in Pepr Guide"},{"body":"Pepr fully supports WebAssembly. Depending on the language used to generate the WASM, certain files can be too large to fit into a Secret or ConfigMap. Due to this limitation, users have the ability to incorporate *.wasm and any other essential files during the build phase, which are then embedded into the Pepr Controller container. This is achieved through adding an array of files to the includedFiles section under pepr in the package.json.\nNOTE - In order to instantiate the WebAsembly module in TypeScript, you need the WebAssembly type. This is accomplished through add the “DOM” to the lib array in the compilerOptions section of the tsconfig.json. Ex: \"lib\": [\"ES2022\", \"DOM\"]. Be aware that adding the DOM will add a lot of extra types to your project and your developer experience will be impacted in terms of the intellisense.\nHigh-Level Overview WASM support is achieved through adding files as layers atop the Pepr controller image, these files are then able to be read by the individual capabilities. The key components of WASM support are:\nAdd files to the base of the Pepr module. Reference the files in the includedFiles section of the pepr block of the package.json Run npx pepr build with the -r option specifying registry info. Ex: npx pepr build -r docker.io/cmwylie19 Pepr builds and pushes a custom image that is used in the Deployment. Using WASM Support Creating a WASM Module in Go Create a simple Go function that you want to call from your Pepr module\npackage main import ( \"fmt\" \"syscall/js\" ) func concats(this js.Value, args []js.Value) interface{} { fmt.Println(\"PeprWASM!\") stringOne := args[0].String() stringTwo := args[1].String() return fmt.Sprintf(\"%s%s\", stringOne, stringTwo) } func main() { done := make(chan struct{}, 0) js.Global().Set(\"concats\", js.FuncOf(concats)) \u003c-done } Compile it to a wasm target and move it to your Pepr module\nGOOS=js GOARCH=wasm go build -o main.wasm cp main.wasm $YOUR_PEPR_MODULE/ Copy the wasm_exec.js from GOROOT to your Pepr Module\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" $YOUR_PEPR_MODULE/ Update the polyfill to add globalThis.crypto in the wasm_exec.js since we are not running in the browser. This is needed directly under: (() =\u003e {\n// Initialize the polyfill if (typeof globalThis.crypto === 'undefined') { globalThis.crypto = { getRandomValues: (array) =\u003e { for (let i = 0; i \u003c array.length; i++) { array[i] = Math.floor(Math.random() * 256); } }, }; } Configure Pepr to use WASM After adding the files to the root of the Pepr module, reference those files in the package.json:\n{ \"name\": \"pepr-test-module\", \"version\": \"0.0.1\", \"description\": \"A test module for Pepr\", \"keywords\": [ \"pepr\", \"k8s\", \"policy-engine\", \"pepr-module\", \"security\" ], \"engines\": { \"node\": \"\u003e=18.0.0\" }, \"pepr\": { \"name\": \"pepr-test-module\", \"uuid\": \"static-test\", \"onError\": \"ignore\", \"alwaysIgnore\": { \"namespaces\": [], \"labels\": [] }, \"includedFiles\":[ \"main.wasm\", \"wasm_exec.js\" ] }, ... } Update the tsconfig.json to add “DOM” to the compilerOptions lib:\n{ \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, \"declaration\": true, \"declarationMap\": true, \"emitDeclarationOnly\": true, \"esModuleInterop\": true, \"lib\": [ \"ES2022\", \"DOM\" // \u003c- Add this ], \"module\": \"CommonJS\", \"moduleResolution\": \"node\", \"outDir\": \"dist\", \"resolveJsonModule\": true, \"rootDir\": \".\", \"strict\": false, \"target\": \"ES2022\", \"useUnknownInCatchVariables\": false }, \"include\": [ \"**/*.ts\" ] } Call WASM functions from TypeScript Import the wasm_exec.js in the pepr.ts\nimport \"./wasm_exec.js\"; Create a helper function to load the wasm file in a capability and call it during an event of your choice\nasync function callWASM(a,b) { const go = new globalThis.Go(); const wasmData = readFileSync(\"main.wasm\"); var concated: string; await WebAssembly.instantiate(wasmData, go.importObject).then(wasmModule =\u003e { go.run(wasmModule.instance); concated = global.concats(a,b); }); return concated; } When(a.Pod) .IsCreated() .Mutate(async pod =\u003e { try { let label_value = await callWASM(\"loves\",\"wasm\") pod.SetLabel(\"pepr\",label_value) } catch(err) { Log.error(err); } }); Run Pepr Build Build your Pepr module with the registry specified.\nnpx pepr build -r docker.io/defenseunicorns ","categories":"","description":"","excerpt":"Pepr fully supports WebAssembly. Depending on the language used to …","ref":"/v0.20.1/webassembly/","tags":"","title":"WASM Support Running WebAssembly in Pepr Guide"},{"body":"Pepr fully supports WebAssembly. Depending on the language used to generate the WASM, certain files can be too large to fit into a Secret or ConfigMap. Due to this limitation, users have the ability to incorporate *.wasm and any other essential files during the build phase, which are then embedded into the Pepr Controller container. This is achieved through adding an array of files to the includedFiles section under pepr in the package.json.\nNOTE - In order to instantiate the WebAsembly module in TypeScript, you need the WebAssembly type. This is accomplished through add the “DOM” to the lib array in the compilerOptions section of the tsconfig.json. Ex: \"lib\": [\"ES2022\", \"DOM\"]. Be aware that adding the DOM will add a lot of extra types to your project and your developer experience will be impacted in terms of the intellisense.\nHigh-Level Overview WASM support is achieved through adding files as layers atop the Pepr controller image, these files are then able to be read by the individual capabilities. The key components of WASM support are:\nAdd files to the base of the Pepr module. Reference the files in the includedFiles section of the pepr block of the package.json Run npx pepr build with the -r option specifying registry info. Ex: npx pepr build -r docker.io/cmwylie19 Pepr builds and pushes a custom image that is used in the Deployment. Using WASM Support Creating a WASM Module in Go Create a simple Go function that you want to call from your Pepr module\npackage main import ( \"fmt\" \"syscall/js\" ) func concats(this js.Value, args []js.Value) interface{} { fmt.Println(\"PeprWASM!\") stringOne := args[0].String() stringTwo := args[1].String() return fmt.Sprintf(\"%s%s\", stringOne, stringTwo) } func main() { done := make(chan struct{}, 0) js.Global().Set(\"concats\", js.FuncOf(concats)) \u003c-done } Compile it to a wasm target and move it to your Pepr module\nGOOS=js GOARCH=wasm go build -o main.wasm cp main.wasm $YOUR_PEPR_MODULE/ Copy the wasm_exec.js from GOROOT to your Pepr Module\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" $YOUR_PEPR_MODULE/ Update the polyfill to add globalThis.crypto in the wasm_exec.js since we are not running in the browser. This is needed directly under: (() =\u003e {\n// Initialize the polyfill if (typeof globalThis.crypto === 'undefined') { globalThis.crypto = { getRandomValues: (array) =\u003e { for (let i = 0; i \u003c array.length; i++) { array[i] = Math.floor(Math.random() * 256); } }, }; } Configure Pepr to use WASM After adding the files to the root of the Pepr module, reference those files in the package.json:\n{ \"name\": \"pepr-test-module\", \"version\": \"0.0.1\", \"description\": \"A test module for Pepr\", \"keywords\": [ \"pepr\", \"k8s\", \"policy-engine\", \"pepr-module\", \"security\" ], \"engines\": { \"node\": \"\u003e=18.0.0\" }, \"pepr\": { \"name\": \"pepr-test-module\", \"uuid\": \"static-test\", \"onError\": \"ignore\", \"alwaysIgnore\": { \"namespaces\": [], \"labels\": [] }, \"includedFiles\":[ \"main.wasm\", \"wasm_exec.js\" ] }, ... } Update the tsconfig.json to add “DOM” to the compilerOptions lib:\n{ \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, \"declaration\": true, \"declarationMap\": true, \"emitDeclarationOnly\": true, \"esModuleInterop\": true, \"lib\": [ \"ES2022\", \"DOM\" // \u003c- Add this ], \"module\": \"CommonJS\", \"moduleResolution\": \"node\", \"outDir\": \"dist\", \"resolveJsonModule\": true, \"rootDir\": \".\", \"strict\": false, \"target\": \"ES2022\", \"useUnknownInCatchVariables\": false }, \"include\": [ \"**/*.ts\" ] } Call WASM functions from TypeScript Import the wasm_exec.js in the pepr.ts\nimport \"./wasm_exec.js\"; Create a helper function to load the wasm file in a capability and call it during an event of your choice\nasync function callWASM(a,b) { const go = new globalThis.Go(); const wasmData = readFileSync(\"main.wasm\"); var concated: string; await WebAssembly.instantiate(wasmData, go.importObject).then(wasmModule =\u003e { go.run(wasmModule.instance); concated = global.concats(a,b); }); return concated; } When(a.Pod) .IsCreated() .Mutate(async pod =\u003e { try { let label_value = await callWASM(\"loves\",\"wasm\") pod.SetLabel(\"pepr\",label_value) } catch(err) { Log.error(err); } }); Run Pepr Build Build your Pepr module with the registry specified.\nnpx pepr build -r docker.io/defenseunicorns ","categories":"","description":"","excerpt":"Pepr fully supports WebAssembly. Depending on the language used to …","ref":"/v0.20.2/webassembly/","tags":"","title":"WASM Support Running WebAssembly in Pepr Guide"},{"body":"Pepr fully supports WebAssembly. Depending on the language used to generate the WASM, certain files can be too large to fit into a Secret or ConfigMap. Due to this limitation, users have the ability to incorporate *.wasm and any other essential files during the build phase, which are then embedded into the Pepr Controller container. This is achieved through adding an array of files to the includedFiles section under pepr in the package.json.\nNOTE - In order to instantiate the WebAsembly module in TypeScript, you need the WebAssembly type. This is accomplished through add the “DOM” to the lib array in the compilerOptions section of the tsconfig.json. Ex: \"lib\": [\"ES2022\", \"DOM\"]. Be aware that adding the DOM will add a lot of extra types to your project and your developer experience will be impacted in terms of the intellisense.\nHigh-Level Overview WASM support is achieved through adding files as layers atop the Pepr controller image, these files are then able to be read by the individual capabilities. The key components of WASM support are:\nAdd files to the base of the Pepr module. Reference the files in the includedFiles section of the pepr block of the package.json Run npx pepr build with the -r option specifying registry info. Ex: npx pepr build -r docker.io/cmwylie19 Pepr builds and pushes a custom image that is used in the Deployment. Using WASM Support Creating a WASM Module in Go Create a simple Go function that you want to call from your Pepr module\npackage main import ( \"fmt\" \"syscall/js\" ) func concats(this js.Value, args []js.Value) interface{} { fmt.Println(\"PeprWASM!\") stringOne := args[0].String() stringTwo := args[1].String() return fmt.Sprintf(\"%s%s\", stringOne, stringTwo) } func main() { done := make(chan struct{}, 0) js.Global().Set(\"concats\", js.FuncOf(concats)) \u003c-done } Compile it to a wasm target and move it to your Pepr module\nGOOS=js GOARCH=wasm go build -o main.wasm cp main.wasm $YOUR_PEPR_MODULE/ Copy the wasm_exec.js from GOROOT to your Pepr Module\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" $YOUR_PEPR_MODULE/ Update the polyfill to add globalThis.crypto in the wasm_exec.js since we are not running in the browser. This is needed directly under: (() =\u003e {\n// Initialize the polyfill if (typeof globalThis.crypto === 'undefined') { globalThis.crypto = { getRandomValues: (array) =\u003e { for (let i = 0; i \u003c array.length; i++) { array[i] = Math.floor(Math.random() * 256); } }, }; } Configure Pepr to use WASM After adding the files to the root of the Pepr module, reference those files in the package.json:\n{ \"name\": \"pepr-test-module\", \"version\": \"0.0.1\", \"description\": \"A test module for Pepr\", \"keywords\": [ \"pepr\", \"k8s\", \"policy-engine\", \"pepr-module\", \"security\" ], \"engines\": { \"node\": \"\u003e=18.0.0\" }, \"pepr\": { \"name\": \"pepr-test-module\", \"uuid\": \"static-test\", \"onError\": \"ignore\", \"alwaysIgnore\": { \"namespaces\": [], \"labels\": [] }, \"includedFiles\":[ \"main.wasm\", \"wasm_exec.js\" ] }, ... } Update the tsconfig.json to add “DOM” to the compilerOptions lib:\n{ \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, \"declaration\": true, \"declarationMap\": true, \"emitDeclarationOnly\": true, \"esModuleInterop\": true, \"lib\": [ \"ES2022\", \"DOM\" // \u003c- Add this ], \"module\": \"CommonJS\", \"moduleResolution\": \"node\", \"outDir\": \"dist\", \"resolveJsonModule\": true, \"rootDir\": \".\", \"strict\": false, \"target\": \"ES2022\", \"useUnknownInCatchVariables\": false }, \"include\": [ \"**/*.ts\" ] } Call WASM functions from TypeScript Import the wasm_exec.js in the pepr.ts\nimport \"./wasm_exec.js\"; Create a helper function to load the wasm file in a capability and call it during an event of your choice\nasync function callWASM(a,b) { const go = new globalThis.Go(); const wasmData = readFileSync(\"main.wasm\"); var concated: string; await WebAssembly.instantiate(wasmData, go.importObject).then(wasmModule =\u003e { go.run(wasmModule.instance); concated = global.concats(a,b); }); return concated; } When(a.Pod) .IsCreated() .Mutate(async pod =\u003e { try { let label_value = await callWASM(\"loves\",\"wasm\") pod.SetLabel(\"pepr\",label_value) } catch(err) { Log.error(err); } }); Run Pepr Build Build your Pepr module with the registry specified.\nnpx pepr build -r docker.io/defenseunicorns ","categories":"","description":"","excerpt":"Pepr fully supports WebAssembly. Depending on the language used to …","ref":"/v0.20.3/webassembly/","tags":"","title":"WASM Support Running WebAssembly in Pepr Guide"},{"body":"Pepr fully supports WebAssembly. Depending on the language used to generate the WASM, certain files can be too large to fit into a Secret or ConfigMap. Due to this limitation, users have the ability to incorporate *.wasm and any other essential files during the build phase, which are then embedded into the Pepr Controller container. This is achieved through adding an array of files to the includedFiles section under pepr in the package.json.\nNOTE - In order to instantiate the WebAsembly module in TypeScript, you need the WebAssembly type. This is accomplished through add the “DOM” to the lib array in the compilerOptions section of the tsconfig.json. Ex: \"lib\": [\"ES2022\", \"DOM\"]. Be aware that adding the DOM will add a lot of extra types to your project and your developer experience will be impacted in terms of the intellisense.\nHigh-Level Overview WASM support is achieved through adding files as layers atop the Pepr controller image, these files are then able to be read by the individual capabilities. The key components of WASM support are:\nAdd files to the base of the Pepr module. Reference the files in the includedFiles section of the pepr block of the package.json Run npx pepr build with the -r option specifying registry info. Ex: npx pepr build -r docker.io/cmwylie19 Pepr builds and pushes a custom image that is used in the Deployment. Using WASM Support Creating a WASM Module in Go Create a simple Go function that you want to call from your Pepr module\npackage main import ( \"fmt\" \"syscall/js\" ) func concats(this js.Value, args []js.Value) interface{} { fmt.Println(\"PeprWASM!\") stringOne := args[0].String() stringTwo := args[1].String() return fmt.Sprintf(\"%s%s\", stringOne, stringTwo) } func main() { done := make(chan struct{}, 0) js.Global().Set(\"concats\", js.FuncOf(concats)) \u003c-done } Compile it to a wasm target and move it to your Pepr module\nGOOS=js GOARCH=wasm go build -o main.wasm cp main.wasm $YOUR_PEPR_MODULE/ Copy the wasm_exec.js from GOROOT to your Pepr Module\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" $YOUR_PEPR_MODULE/ Update the polyfill to add globalThis.crypto in the wasm_exec.js since we are not running in the browser. This is needed directly under: (() =\u003e {\n// Initialize the polyfill if (typeof globalThis.crypto === 'undefined') { globalThis.crypto = { getRandomValues: (array) =\u003e { for (let i = 0; i \u003c array.length; i++) { array[i] = Math.floor(Math.random() * 256); } }, }; } Configure Pepr to use WASM After adding the files to the root of the Pepr module, reference those files in the package.json:\n{ \"name\": \"pepr-test-module\", \"version\": \"0.0.1\", \"description\": \"A test module for Pepr\", \"keywords\": [ \"pepr\", \"k8s\", \"policy-engine\", \"pepr-module\", \"security\" ], \"engines\": { \"node\": \"\u003e=18.0.0\" }, \"pepr\": { \"name\": \"pepr-test-module\", \"uuid\": \"static-test\", \"onError\": \"ignore\", \"alwaysIgnore\": { \"namespaces\": [], \"labels\": [] }, \"includedFiles\":[ \"main.wasm\", \"wasm_exec.js\" ] }, ... } Update the tsconfig.json to add “DOM” to the compilerOptions lib:\n{ \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, \"declaration\": true, \"declarationMap\": true, \"emitDeclarationOnly\": true, \"esModuleInterop\": true, \"lib\": [ \"ES2022\", \"DOM\" // \u003c- Add this ], \"module\": \"CommonJS\", \"moduleResolution\": \"node\", \"outDir\": \"dist\", \"resolveJsonModule\": true, \"rootDir\": \".\", \"strict\": false, \"target\": \"ES2022\", \"useUnknownInCatchVariables\": false }, \"include\": [ \"**/*.ts\" ] } Call WASM functions from TypeScript Import the wasm_exec.js in the pepr.ts\nimport \"./wasm_exec.js\"; Create a helper function to load the wasm file in a capability and call it during an event of your choice\nasync function callWASM(a,b) { const go = new globalThis.Go(); const wasmData = readFileSync(\"main.wasm\"); var concated: string; await WebAssembly.instantiate(wasmData, go.importObject).then(wasmModule =\u003e { go.run(wasmModule.instance); concated = global.concats(a,b); }); return concated; } When(a.Pod) .IsCreated() .Mutate(async pod =\u003e { try { let label_value = await callWASM(\"loves\",\"wasm\") pod.SetLabel(\"pepr\",label_value) } catch(err) { Log.error(err); } }); Run Pepr Build Build your Pepr module with the registry specified.\nnpx pepr build -r docker.io/defenseunicorns ","categories":"","description":"","excerpt":"Pepr fully supports WebAssembly. Depending on the language used to …","ref":"/v0.21.0/webassembly/","tags":"","title":"WASM Support Running WebAssembly in Pepr Guide"},{"body":"Pepr fully supports WebAssembly. Depending on the language used to generate the WASM, certain files can be too large to fit into a Secret or ConfigMap. Due to this limitation, users have the ability to incorporate *.wasm and any other essential files during the build phase, which are then embedded into the Pepr Controller container. This is achieved through adding an array of files to the includedFiles section under pepr in the package.json.\nNOTE - In order to instantiate the WebAsembly module in TypeScript, you need the WebAssembly type. This is accomplished through add the “DOM” to the lib array in the compilerOptions section of the tsconfig.json. Ex: \"lib\": [\"ES2022\", \"DOM\"]. Be aware that adding the DOM will add a lot of extra types to your project and your developer experience will be impacted in terms of the intellisense.\nHigh-Level Overview WASM support is achieved through adding files as layers atop the Pepr controller image, these files are then able to be read by the individual capabilities. The key components of WASM support are:\nAdd files to the base of the Pepr module. Reference the files in the includedFiles section of the pepr block of the package.json Run npx pepr build with the -r option specifying registry info. Ex: npx pepr build -r docker.io/cmwylie19 Pepr builds and pushes a custom image that is used in the Deployment. Using WASM Support Creating a WASM Module in Go Create a simple Go function that you want to call from your Pepr module\npackage main import ( \"fmt\" \"syscall/js\" ) func concats(this js.Value, args []js.Value) interface{} { fmt.Println(\"PeprWASM!\") stringOne := args[0].String() stringTwo := args[1].String() return fmt.Sprintf(\"%s%s\", stringOne, stringTwo) } func main() { done := make(chan struct{}, 0) js.Global().Set(\"concats\", js.FuncOf(concats)) \u003c-done } Compile it to a wasm target and move it to your Pepr module\nGOOS=js GOARCH=wasm go build -o main.wasm cp main.wasm $YOUR_PEPR_MODULE/ Copy the wasm_exec.js from GOROOT to your Pepr Module\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" $YOUR_PEPR_MODULE/ Update the polyfill to add globalThis.crypto in the wasm_exec.js since we are not running in the browser. This is needed directly under: (() =\u003e {\n// Initialize the polyfill if (typeof globalThis.crypto === 'undefined') { globalThis.crypto = { getRandomValues: (array) =\u003e { for (let i = 0; i \u003c array.length; i++) { array[i] = Math.floor(Math.random() * 256); } }, }; } Configure Pepr to use WASM After adding the files to the root of the Pepr module, reference those files in the package.json:\n{ \"name\": \"pepr-test-module\", \"version\": \"0.0.1\", \"description\": \"A test module for Pepr\", \"keywords\": [ \"pepr\", \"k8s\", \"policy-engine\", \"pepr-module\", \"security\" ], \"engines\": { \"node\": \"\u003e=18.0.0\" }, \"pepr\": { \"name\": \"pepr-test-module\", \"uuid\": \"static-test\", \"onError\": \"ignore\", \"alwaysIgnore\": { \"namespaces\": [], \"labels\": [] }, \"includedFiles\":[ \"main.wasm\", \"wasm_exec.js\" ] }, ... } Update the tsconfig.json to add “DOM” to the compilerOptions lib:\n{ \"compilerOptions\": { \"allowSyntheticDefaultImports\": true, \"declaration\": true, \"declarationMap\": true, \"emitDeclarationOnly\": true, \"esModuleInterop\": true, \"lib\": [ \"ES2022\", \"DOM\" // \u003c- Add this ], \"module\": \"CommonJS\", \"moduleResolution\": \"node\", \"outDir\": \"dist\", \"resolveJsonModule\": true, \"rootDir\": \".\", \"strict\": false, \"target\": \"ES2022\", \"useUnknownInCatchVariables\": false }, \"include\": [ \"**/*.ts\" ] } Call WASM functions from TypeScript Import the wasm_exec.js in the pepr.ts\nimport \"./wasm_exec.js\"; Create a helper function to load the wasm file in a capability and call it during an event of your choice\nasync function callWASM(a,b) { const go = new globalThis.Go(); const wasmData = readFileSync(\"main.wasm\"); var concated: string; await WebAssembly.instantiate(wasmData, go.importObject).then(wasmModule =\u003e { go.run(wasmModule.instance); concated = global.concats(a,b); }); return concated; } When(a.Pod) .IsCreated() .Mutate(async pod =\u003e { try { let label_value = await callWASM(\"loves\",\"wasm\") pod.SetLabel(\"pepr\",label_value) } catch(err) { Log.error(err); } }); Run Pepr Build Build your Pepr module with the registry specified.\nnpx pepr build -r docker.io/defenseunicorns ","categories":"","description":"","excerpt":"Pepr fully supports WebAssembly. Depending on the language used to …","ref":"/v0.21.1/webassembly/","tags":"","title":"WASM Support Running WebAssembly in Pepr Guide"}]