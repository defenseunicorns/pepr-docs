import * as fs from 'node:fs/promises';
import * as util from 'node:util';
import * as child_process from 'node:child_process';
import * as semver from 'semver';

const exec = util.promisify(child_process.exec);

/**
 * Manual redirects configuration
 * Add redirects here that should be included in the generated _redirects file
 */
const MANUAL_REDIRECTS = {
	// Legacy Doc Conversion Redirects - /main to root
	'/main/*': '/:splat',
	'/latest/*': '/:splat',

	// General path fixes (non-versioned)
	'/code_of_conduct': '/contribute/code-of-conduct',
	'/support': '/community/support',
	'/security': '/community/security',
	'/contribute': '/contribute/contributor-guide',
	'/metrics-endpoints': '/metric',
	'/pepr-tutorials/': '/tutorials/',

};

/**
 * Generate Netlify _redirects file with retired versions, manual redirects, and patch-to-minor redirects
 * @param {Object} options
 * @param {string} options.coreRepoPath - Path to the core repository
 * @param {string[]} options.retiredVersions - Array of retired major.minor versions (e.g., ['0.53', '0.52'])
 * @param {string[]} options.activeVersions - Array of active version tags (e.g., ['v0.54.0', 'v0.55.1'])
 * @param {string} options.outputPath - Path to write the _redirects file
 * @returns {Promise<{totalRules: number, retiredCount: number, manualCount: number, patchCount: number}>}
 */
export async function generateNetlifyRedirects({ coreRepoPath, retiredVersions, activeVersions, outputPath }) {
	const redirectLines = [
		'# Auto-generated redirects for Pepr documentation',
		'# Generated by build/redirects-generator.mjs - DO NOT EDIT MANUALLY',
		'',
	];

	// Get all tags from the repository
	const { stdout } = await exec('git tag', { cwd: coreRepoPath });
	const allTags = stdout.trim().split('\n').filter(Boolean).filter(semver.valid);

	// Section 1: Retired version redirects (highest priority)
	redirectLines.push('# ============================================');
	redirectLines.push('# Retired Version Redirects');
	redirectLines.push('# Redirect old documentation versions to root');
	redirectLines.push('# ============================================');
	redirectLines.push('');

	let retiredCount = 0;
	for (const majmin of retiredVersions) {
		// Add major.minor redirect
		redirectLines.push(`/v${majmin}/*  /:splat  301`);
		retiredCount++;

		// Add all patch version redirects for this major.minor
		const patchVersions = allTags
			.filter(v => {
				const match = v.match(/^v(\d+\.\d+)\.(\d+)$/);
				return match && match[1] === majmin;
			});

		for (const patchVersion of patchVersions) {
			redirectLines.push(`/${patchVersion}/*  /:splat  301`);
			retiredCount++;
		}
	}

	// Section 2: Manual redirects (medium priority - specific paths)
	redirectLines.push('');
	redirectLines.push('# ============================================');
	redirectLines.push('# Manual Redirects');
	redirectLines.push('# Specific path redirects and fixes');
	redirectLines.push('# ============================================');
	redirectLines.push('');

	let manualCount = 0;
	for (const [from, to] of Object.entries(MANUAL_REDIRECTS)) {
		// Normalize paths - if they don't have wildcards, add them
		let fromPath = from;
		let toPath = to;

		if (!from.includes('*') && !from.includes(':path')) {
			fromPath = `${from}/*`;
		}

		if (!to.includes('*') && !to.includes(':')) {
			toPath = `${to}/:splat`;
		}

		redirectLines.push(`${fromPath}  ${toPath}  301`);
		manualCount++;
	}

	// Section 3: Automatic patch-to-minor redirects (lowest priority - catch-all)
	redirectLines.push('');
	redirectLines.push('# ============================================');
	redirectLines.push('# Automatic Patch-to-Minor Redirects');
	redirectLines.push('# Redirect patch versions to major.minor');
	redirectLines.push('# (e.g., /v0.54.0/* -> /v0.54/*)');
	redirectLines.push('# ============================================');
	redirectLines.push('');

	// Get all non-retired major.minor versions
	const stableVersions = activeVersions.filter(v => semver.prerelease(v) === null);
	const activeMajorMinors = [...new Set(stableVersions.map(v => v.replace(/^v(\d+\.\d+)\.\d+$/, 'v$1')))];

	let patchCount = 0;
	for (const majmin of activeMajorMinors) {
		// Find all patch versions for this major.minor
		const patchVersions = allTags.filter(v => {
			const match = v.match(/^v(\d+\.\d+)\.(\d+)$/);
			return match && `v${match[1]}` === majmin;
		});

		// For each patch version, create redirects to major.minor
		for (const patchVersion of patchVersions) {
			// Exact version path (e.g., /v0.54.0 -> /v0.54)
			redirectLines.push(`/${patchVersion}  /${majmin}  301`);
			// Version subpaths (e.g., /v0.54.0/* -> /v0.54/:splat)
			redirectLines.push(`/${patchVersion}/*  /${majmin}/:splat  301`);
			patchCount += 2;
		}
	}

	// Write the file
	const content = redirectLines.join('\n') + '\n';
	await fs.writeFile(outputPath, content);

	const totalRules = retiredCount + manualCount + patchCount;
	return {
		totalRules,
		retiredCount,
		manualCount,
		patchCount,
	};
}

/**
 * Get filter function for stable versions (non-latest, non-prerelease)
 * @param {string[]} versions - Array of version strings
 * @returns {string[]} - Filtered stable versions
 */
export function getStableVersions(versions) {
	return versions.filter(v => v !== 'latest' && semver.prerelease(v) === null);
}
